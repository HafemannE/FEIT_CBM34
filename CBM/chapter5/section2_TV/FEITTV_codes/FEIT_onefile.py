from mshr import*
import numpy as np
from fenics import*


class electrodes_position():    
    """Object that contains the position of the electrodes in boundary.
        The position is stored in function of angle theta initial and final of each electrode.
    
        :param L: Number electrodes.
        :type L: int.
        :param per_cober: Percentual covered lenght in boundary by electrodes, between 0 and 1. 
        :type per_cober: float.
        :param rotate: Rotation angle in the original solution for electrodes.
        :type rotate: float.
        
        :Example:
            >>> ele_pos=electrodes_position(L=16, per_cober=0.5, rotate=0)
            >>> print(ele_pos.position)
            [[0.0, 0.19634954084936207],
             [0.39269908169872414, 0.5890486225480862],
             [0.7853981633974483, 0.9817477042468103],
             [1.1780972450961724, 1.3744467859455345],
             [1.5707963267948966, 1.7671458676442586],
             ...,
             [5.890486225480862, 6.086835766330224]]
            
        """
    
    def __init__(self, L, per_cober, rotate, anticlockwise=True):
        #Checks
        if not isinstance(L, int): raise ValueError("Number of electrodes must be an integer.")
        if not isinstance(per_cober, float): raise ValueError("per_cober must be a float.")
        if not isinstance(rotate, (int, float)): raise ValueError("rotate must be a float.")
        if not isinstance(anticlockwise, bool): raise ValueError("anticlockwise must be true of false.")
        if per_cober>1: raise ValueError("per_cober must be equal or less than 1. Example (75%): per_cober=0.75 ")
        
        self.rotate=rotate
        self.L=L
        self.per_cober=per_cober
        self.anticlockwise=anticlockwise

        self.position=self.calc_position()
    
    
    def calc_position(self):
        """Calculate the position of electrodes based in :class:`electrodes_position()` object.
        
        :returns:  list of arrays -- Return list with angle initial and final of each electrode."""
        size_e=2*pi/self.L*self.per_cober       #Size electrodes
        size_gap=2*pi/self.L*(1-self.per_cober) #Size gaps
        rotate=self.rotate                      #Rotating original solution

        electrodes=[]
        for i in range(self.L):
            #Example electrodes=[[0, pi/4], [pi/2, pi]]
            electrodes.append([size_e*i+size_gap*i+rotate, size_e*(i+1)+size_gap*i+rotate]) #Grouping angular values for electrodes.
        if not self.anticlockwise:
            electrodes[1:] = electrodes[1:][::-1] #Keep first electrode and reverse order
        return electrodes

def MyMesh(r, n, n_in, n_out, electrodes_obj):
    """Function that generate the mesh based in the electrodes position

    :param r: Circle Radius
    :type r: float.
    :param n: Refinament parameter
    :type n: int.
    :param n_in: Vertices number in electrodes
    :type n_in: int
    :param n_out: Vertices number in gaps.
    :type n_out: int
    :param electrodes_obj: Object.
    :type electrodes_obj: :class:`electrodes_position()`

    :return: :class:`dolfin.cpp.mesh.Mesh`

    :Example:
            >>> ele_pos=electrodes_position(L=16, per_cober=0.5, rotate=0)
            >>> mesh_inverse=MyMesh(r=1, n=8, n_in=6, n_out=1, electrodes_obj=ele_pos)
            >>> mesh_forward=MyMesh(r=1, n=8*3, n_in=6*3, n_out=1*3, electrodes_obj=ele_pos)

    .. image:: codes/mesh.png
      :scale: 75 %

    """

    electrodes=np.copy(electrodes_obj.position)
    L=electrodes_obj.L
    rotate=electrodes_obj.rotate
    anticlockwise= electrodes_obj.anticlockwise
    
    if not isinstance(r, (int, float)): raise ValueError("radius must be a float or an integer.")
    if not isinstance(n, (int, float)): raise ValueError("n must be a float or an integer.")
    #if not isinstance(n_in, int): raise ValueError("Vertices number in electrodes must be integer or an array of integers.")
    #if not isinstance(n_out, int): raise ValueError("Vertices number in gaps must be integer or an array of integers.")
    if not isinstance(electrodes_obj, electrodes_position): raise Exception("Electrodes_obj must be generated by electrodes_position().")
 
    

    if isinstance(n_in, int): n_in=np.ones(L)*n_in
    if isinstance(n_out, int): n_out=np.ones(L+L)*n_out


    ###Points Generator###
    points=[]
    save_points=[]
    save_vertex=[]
    save_vertex_elec=[]
    if not anticlockwise:  electrodes[1:] = electrodes[1:][::-1] #Fenics only accepts anticlockwise
    for i in range(L):
        save_vertex=[]
        #Creating vertex on the electrodes.
        theta0, thetai= electrodes[i][0], electrodes[i][1]
        for theta in np.linspace(theta0, thetai, int(n_in[i])):
            a=[Point((cos(theta)*r,sin(theta)*r))]     #Defining Point object from Fenics.
            points=np.concatenate((points,a), axis=0)  #Grouping points.
            vertex_cord=[cos(theta)*r,sin(theta)*r]    #Creating elec vertex on the boundary in anti-clockwise.
            save_vertex.append(vertex_cord)            #Grouping vertex positions in R2

        #Selecting the last gap with the first electrode.
        if i<L-1: theta0, thetai= electrodes[i][1], electrodes[i+1][0]
        else: theta0, thetai= electrodes[i][1], 2*pi+rotate
        
        #Creating vertex on the gaps.
        for theta in np.linspace(theta0, thetai, int(n_out[i])+2):
            if theta!=theta0 and theta!=thetai:
                a=[Point((cos(theta)*r,sin(theta)*r))]    #Creating gap vertex on the boundary in anti-clockwise.
                points=np.concatenate((points,a), axis=0) #Grouping points.
        
        save_vertex_elec.append(save_vertex) #Grouping list of vertex in the electrode i.

    if not anticlockwise:  
        save_vertex_elec[1:] = save_vertex_elec[1:][::-1] #Pass vertex in clockwise pattern

    domain = Polygon(points)          #Function creates a polygon with the points.
    mesh = generate_mesh(domain,n)    #Get the polygon and generate the mesh
    mesh.radius=r                     #Information input in the mesh.
    mesh.vertex_elec=save_vertex_elec #Pass the vertex position of the electrodes to the object memory. It will be used in fowward problem.
    mesh.electrodes=electrodes_obj   #Pass the electrodes object to mesh
    return mesh

import scipy

def current_method(L,l, method=1, value=1):
    """This function create a numpy array (or a list of arrays) that represent the current density in the electrodes.
    
    :param L: Number electrodes.
    :type L: int
    :param l: Measurements number.
    :type l: int
    :param method: Current pattern.
    :type method: int
    :returns:  list of arrays -- Return list with current density in each electrode for each measurement.
    
    Method Values:           
        1. 1 and -1 in opposite electrodes
        2. 1 and -1 in adjacent electrodes
        3. 1 in one electrode and -1/(L-1) for the rest
        4. For measureament k, we have: (sin(k*2*pi/16) sin(2*k*2*pi/16) ... sin(16*k*2*pi/16))
        
        
    :Example:

    >>> I_all=current_method(L=4,l=4, method=1)
    >>> print(I_all)
        [array([ 1.,  0., -1.,  0.]),
        array([ 0.,  1.,  0., -1.]),
        array([-1.,  0.,  1.,  0.]),
        array([ 0., -1.,  0.,  1.])]
    
    >>> I_all=current_method(L=4,l=4, method=2)
    >>> print(I_all)
        [array([ 1.,  -1., 0.,  0.]),
        array([ 0.,  1.,  -1., 0.]),
        array([0.,  0.,  1.,  -1.]),
        array([ 1., 0.,  0.,  -1.])]
    
        """
    
    I_all=[]
    #Type "(1,0,0,0,-1,0,0,0)"
    if method==1:
        if L%2!=0: raise Exception("L must be odd.")
                                   
        for i in range(l):
            if i<=L/2-1:
                I=np.zeros(L)
                I[i], I[i+int(L/2)]=value, -value
                I_all.append(I)
            elif i==L/2:
                print("This method only accept until L/2 currents, returning L/2 currents.")
    #Type "(1,-1,0,0...)"
    if method==2:
        for i in range(l):
            if i!=L-1:
                I=np.zeros(L)
                I[i], I[i+1]=value, -value
                I_all.append(I)
            else: 
                I=np.zeros(L)
                I[0], I[i]=-value, value
                I_all.append(I)
    #Type "(1,-1/15, -1/15, ....)"
    if method==3:
        for i in range(l):
            I=np.ones(L)*-value/(L-1)
            I[i]=value
            I_all.append(I)
    #Type "(sin(k*2*pi/16) sin(2*k*2*pi/16) ... sin(16*k*2*pi/16))"
    if method==4:
        for i in range(l):
            I=np.ones(L)
            for k in range(L): I[k]=I[k]*sin((i+1)*(k+1)*2*pi/L) 
            I_all.append(I)

            
    if l==1: I_all=I_all[0]
    return np.array(I_all)

def fn_addnoise(data, level, noise_type='uniform', seed=42):
    """Function receives a vector which represents the data in the electrodes and returns
    a noised vector with the chosen noise level and the type of noise.
    We use it in :func:`ForwardProblem.add_noise`.
    
    :param data: Vector with potencial in electrodes or any other vector.
    :type data: array
    :param level: Noise level (%), expect values between 0 and 1.
    :type level: float
    :param noise_type: Noise type, uniform or cauchy.
    :type method: str.
    :param seed: Seed for random function.
    :type seed: int.
    
    
    :returns:  Array -- Return noised vector.
    
    :Example:

    >>> print(np.ones(8))
    >>> print(fn_addnoise(data=np.ones(8), level=0.01, noise_type='cauchy', seed=32))
        [1. 1. 1. 1. 1. 1. 1. 1.]
        array([0.99905327, 1.02206251, 1.00356633, 1.00236212, 1.00101231, 0.99904405, 1.0105611 , 0.98656216])
    
    """
    i = len(data)
    # create 1D numpy data:
    npdata = np.asarray(data).reshape((i))
    delta=level*np.linalg.norm(npdata) #delta = noise_level * ||data||_2
    
    #add f normal noise:
    if noise_type=='uniform':
        np.random.seed(seed)                             #Set seed to generate random noise
        noise_f=np.random.randn(npdata.size)             #Generate random noise with vector size of data.
        noise_f=noise_f/np.linalg.norm(noise_f)*delta    #Normalize random noise and multiply by delta.
        noise = npdata + noise_f                         #Add noise to the vector.
    # add cauchy noise:
    elif noise_type=='cauchy':   
    #12 31 59
        np.random.seed(seed)                                     #Set seed to generate random noise
        noise_p = np.random.standard_cauchy(size=npdata.shape)   #Generate random noise with vector size of data.
        noise_p=noise_p/np.linalg.norm(noise_p)*delta            #Normalize random noise and multiply by delta
        noise = npdata + noise_p                                 #Add noise to the vector.
        
    return noise

class electrode_domain(SubDomain):
    """Auxiliar function for ForwardProblem to define electrode domain.
    We expect that the domain is a circle.
    This routine determine the vertices where the electrodes are defined and mark the mesh.
    We use it in :func:`ForwardProblem.electrodes`.
    
    :param electrode: Initial and final angle position of electrode.
    :type electrode: Array
    :param radius: Circle radius.
    :type radius: float
    """
    def __init__(self, mesh_vertex, radius, L):   #Observe that mesh_vertex is from electrode i.
        super(electrode_domain, self).__init__()  #init subclass
        self.mesh_vertex=np.array(mesh_vertex).T  #Getting vertex electrodes from mesh.
        self.L=L                                  #Setting electrodes number.
        self.X=np.max(self.mesh_vertex[0])        #Max value axis x
        self.X1=np.min(self.mesh_vertex[0])       #Min value axis x 
        self.Y=np.max(self.mesh_vertex[1])        #Max value axis y
        self.Y1=np.min(self.mesh_vertex[1])       #Max value axis y
        
    def inside(self, x, on_boundary):  #Fenics functions that evals where is the Subdomain setting True os false on the vertex.
        #Here we implemented a strategy to verify if the vertex is part of electrode or nop.
        #Fenics get only vertex on boundary for us. After that we verify if the vertex is inside a "box" at (X1,X) x (Y1,Y).
        if on_boundary:  #If elemente is on boundary.
            #If vertex coordinate x are is bewteen...
            if between(x[0],((self.X),(self.X1))) or  between(x[0],((self.X1,(self.X)))):
                #If vertex coordinate y are is bewteen...
                if between(x[1],((self.Y),(self.Y1))) or  between(x[1],((self.Y1,(self.Y)))):
                    return True  #Ok, this vertex is part of my electrode.
                else:
                    return False #Nope, this isn't into electrode.


def GammaCircle(mesh, in_v, out_v, radius,centerx, centery):
    """Function to create a circle in the mesh with some proprieties
    
        :param mesh: Mesh.
        :type mesh: :class:`dolfin.cpp.mesh.Mesh`
        :param in_v: Value inside circle
        :type in_v: float
        :param out_v: Value outside circle
        :type out_v: float
        :param radius: Circle radius
        :type radius: float
        :param centerx: Circle center position x
        :type centerx: float
        :param centery: Circle center position y
        :type centery: float
       
        :returns:  Array -- Return a vector where each position correspond de value of the function in that element.
        
        :Example:

        >>> ValuesCells0=GammaCircle(mesh=mesh_direct, in_v=3.0, out_v=1.0, radius=0.50, centerx=0.25, centery=0.25)
        >>> print(ValuesCells0)
        [1. 1. 1. ... 1. 1. 1.]
        
        >>> "Plot"
        >>> gamma0=CellFunction(mesh_direct, values=ValuesCells0);   
        >>> V_DG=FiniteElement('DG',mesh_direct.ufl_cell(),0)
        >>> plot_figure(mesh_direct, V_DG, gamma0, name="Resposta gamma");
        
        .. image:: gamma.png
           :scale: 75 %

       """
    
    ValuesGamma=np.zeros(mesh.num_cells()) #Null vector
    
    for i in range(0, mesh.num_cells()):
        cell = Cell(mesh, i) #Select cell with index i in the mesh.
        
        vertices=np.array(cell.get_vertex_coordinates()) #Vertex cordinate in the cell.
        x=(vertices[0]+vertices[2]+vertices[4])/3           
        y=(vertices[1]+vertices[3]+vertices[5])/3
        
        #If the baricenter is outside the circle...
        if ((x-centerx)**2+(y-centery)**2>=radius**2):
            ValuesGamma[i]=out_v
        else:
            ValuesGamma[i]=in_v
    
    return ValuesGamma
 

class ForwardProblem(object):
    """ Object Forward Problem EIT 2D
    
        :param mesh: Mesh. We recommend from :func:`MyMesh()`
        :type mesh: :class:`dolfin.cpp.mesh.Mesh`
        :param z:  Vector of impedances in electrodes
        :type z: array
        :param electrodes_obj: Object, list of arrays with position of electrodes.
        :type electrodes_obj: :class:`electrodes_position()`
        
        :Example:
        
        >>> "Basic Definitions"
        >>> L=16
        >>> VD=FiniteElement('CG',mesh_direct.ufl_cell(),1) #Space Solution
        >>> l=int(L)                                        #Measurements number.
        >>> z=np.ones(L)*0.025                              #Impedance
        >>> I_all=current_method(L,l, method=1)             #Current pattern
        
        If you need it, see :func:`electrodes_position`, :func:`GammaCircle` and :func:`CellFunction`.
        
        >>> "Solver"
        >>> DirectProblem=ForwardProblem(mesh_direct,  z)
        >>> list_u0, list_U0 = DirectProblem.solve_forward(VD, gamma0, I_all, l)
        >>> list_U0 = DirectProblem.sol_asarray()
        
        >>> print(list_U0[0:L])
        [ 1.0842557   0.32826713  0.19591977  0.13158264  0.06214628 -0.03412964
         -0.17331413 -0.40308837 -1.18449889 -0.42369776 -0.21120216 -0.08218106
          0.01735219  0.10789938  0.20976791  0.37492101]

    


    """
    
    def __init__(self, mesh, z):
        self.mesh=mesh
        self.z=z
        self.radius=mesh.radius
        self.ele_pos=mesh.electrodes.position     #electrodes position
        self.L=len(self.ele_pos)          #L electrodes.
        self.electrodes()                 #See function below, but it use class electrode_domain to set electrodes region.
        self.assembled=False
            
        
    def electrodes(self):
        """Auxiliar function, define subdomains with electrodes and calculates the size."""
        sub_domains = MeshFunction("size_t", self.mesh, self.mesh.topology().dim()-1) #MeshFunction 
        sub_domains.set_all(0) #Marking all vertex/edges with false.
 
        #Pass electrode position to mesh        
        list_e = [electrode_domain(self.mesh.vertex_elec[i], self.radius, self.L) for i in range(self.L)]
        #Here we have a array with objects that give us the information where is the vertex of each electrode in the mesh.
        
        #Mark electrodes in subdomain
        for index, elec in enumerate(list_e,1): elec.mark(sub_domains, index);
        #Noe we pass the information to the sub_domains with .mark(), where index is the electrode_index. index>=1
        
        #Generate 
        self.de=Measure('ds', domain=self.mesh, subdomain_data=sub_domains) #Defining integration Domain on electrodes.
        self.ele_size=np.array([assemble(Constant(1)*self.de(i+1)) for i in range(self.L)]) #Calc elec_size.
        self.list_e=list_e
        return
    
        
    def solve_forward(self, V, I_all, gamma): 
        """ Solver Forward Problem EIT 2D
            
    :param V: FiniteElement Fenics object
    :param gamma: Finite Element Function
    :param I_all: Current density in each electrode for each measurement
    :type V: FiniteElement
    :type gamma: :func:`CellFunction()`
    :type I_all: :func:`current_method()` or list of arrays
    :type l: int
            
    :returns:  (Array, Array) -- Return a vector where each position correspond de value the solution in the
        domain, and other solution that contains the potencial in the electrodes. Both are Fenics Objects.
        
     :Example:
     >>> DirectProblem=ForwardProblem(mesh_direct,  ele_pos,  z)
     >>> list_u0, list_U0 = DirectProblem.solve_forward(VD, I_all, gamma0)
            
        """
        de=self.de                        #Getting integral domain from memory.
        Intde=self.ele_size               #Size of electrodes.
        mesh=self.mesh
        
        #Verify if is a matrix or a simply vector
        I_all=np.array(I_all)
        self.I_forward=I_all
        if I_all.ndim==2:
            l=len(I_all)
        else: l=1
        
        #Finite element definition
        Rn=VectorElement("R", mesh.ufl_cell(), 0, dim=int(self.L)) #Vector in R_L for electrodes.
        R=FiniteElement("R", mesh.ufl_cell(), 0)                   #Constant for Lang. Mult    
        W=FunctionSpace(mesh, MixedElement([V, Rn, R]))       #Defining Mixed space V x R_l x R
        V_FuncSpace=FunctionSpace(mesh, V)       #Defining Mixed space V x R_l x R
        save_u=[]
        save_U=[]

        u0=TrialFunction(W) #Functions that will be reconstructed.
        v0=TestFunction(W)  #Test functions

        u, un, ul = split(u0)
        v, vn, vl = split(v0)

        # Integral( gamma*<grad_u,grad_v> ) dOmega + lagrMult
        A_inner=assemble(gamma* inner(grad(u),grad(v))*dx)

        if not self.assembled:
            lagrMult=0 #If that we have the ground potential. sum(electrode_i) = 0.
            for i in range(0,self.L): lagrMult+=(vn[i]*ul+un[i]*vl)*de(i+1) #Integral (v_i*u_mult+u_i*v_mult) d(electrode_i)
            self.A_lagr = assemble(lagrMult)


        # Integral 1/zi*(u-U_i)*(v-V_i) d(electrode_i)
        if not self.assembled:
            A_imp_0 = []
            for i in range(self.L): A_imp_0.append(assemble((u-un[i])*(v-vn[i])*de(i+1) ))
            self.A_imp_0 = A_imp_0
        A_imp = np.sum(self.A_imp_0*1/self.z)

        #Make my matriz to solve Ax=b.
        A=A_inner+A_imp+self.A_lagr 
        #We only do it only one time, if have mult. measurements, we reuse it.

        #Split w function in 3 parts, firt the function in H, the vector R^L, and the constant lagr
        w = Function(W) #Define a zero function based in W.
        u,U,u_lagr=w.split() 
        dm0 = W.sub(0).dofmap()
        dm1 = W.sub(1).dofmap()

        b0 = []
        for i in range(self.L): b0.append(assemble(vn[i]*(1/Intde[i])*de(i+1))) #Ax = sum (I_i*V_i)...
        #We integrate over electrode and divide by their size. If we don't make it, we get an error.

        A=scipy.sparse.csc_matrix(A.array())
        for j in range(l):
            I=I_all[j] if l!=1 else I_all #Is one measure or several?
            b = sum([b0[i]*I[i] for i in range(len(b0))]) #Make my b vector
            w = Function(W) #Define a zero function based in W.
            U_vec = w.vector()  #Return a vector. (x=U)
            #solve(A, U_vec, b) #Solve system AU=b. where A matrix and b vector.
            U_vec[:] = scipy.sparse.linalg.spsolve(A, b[:])

            #Append the result.
            u_aux=Function(V_FuncSpace)
            u_aux.vector()[:]= w.vector().vec()[dm0.dofs()]
            save_u.append(u_aux)
            save_U.append(w.vector().vec()[dm1.dofs()])

        self.sol_u, self.sol_U = save_u, save_U
        return self.sol_u, self.sol_U
    
    def sol_asarray(self):
        """ Function that convert potential electrode results in array and concatenate them.
        
             :returns:  Array -- Return a vector with potentials values concatenated, dimension: L*l.
             
             :Example:
            
             >>> list_U0 = DirectProblem.sol_asarray()

        """
        list_U0=self.sol_U
        vec_U0=[]
        for i in range(len(list_U0)): vec_U0=np.concatenate((vec_U0, list_U0[i].vector()[:]), axis=0)
        return vec_U0
    
    def add_noise(self, noise_level=0, noise_type='uniform', seed=42):
        """ Function that add noise in the potential values. The noise is the same for all electrodes.
        If you don't want it, may you should  check: :func:`fn_addnoise`.
        
            :param data: Vector with potencial in electrodes or any other vector.
            :type data: array
            :param level: Noise level (%), expect values between 0 and 1.
            :type level: float
            :param noise_type: Noise type, uniform or cauchy.
            :type noise_type: str.
    
            :returns:  Array -- Return a vector with potentials values concatenated, dimension: L*l and noised.
            
            :Example:
            
            >>> list_U0_noised = DirectProblem.add_noise(noise_level=0.01, noise_type='uniform')
            
        """
        vec_U0=[]
        for i in range(len(self.sol_U)): vec_U0=np.concatenate((
            vec_U0, fn_addnoise(self.sol_U[i], noise_level, noise_type=noise_type, seed=seed)), axis=0)
        return vec_U0
    
    def select_potential(self, data, method=0):
        """ Function that get a vector with the potential values and select a specific order.
        There is only one method. If you use it, you should put select_pot=1 in the InverseObject.

        :param data: Potentials of all experiments.
        :type sol_index: array
        :param method: 0 (do nothing) or 1 (select potential).
        :type method: int

        :returns:  array -- selected potential.

        :Example:
        Suposse that we have 4 electrodes and made 3 measurements. So for each experiment we have 4 potentials.
        [U1, U2, U3, U4], [U5, U6, U7, U8], [U9, U10, U11, U12]. The fuction get the vector [U1, U2, ..., U12] and returns 
        [U2,U3,U4,U7,U8,U12].
        
        .. code-block:: python
    
            selected_U0 = DirectProblem.select_potential(list_U0, method=1)
        
        """
        L=self.L
        if method==1:
            if int(len(data)/L)>=L: raise Exception("This method only works with l<L") 
            data_save=[]
            j=0
            for i in range(np.size(data,0)):
                if i%L>=j:
                    data_save.append(data[i])
                if i%L==0: j+=1
            data_save=np.array(data_save)
            return data_save
        else: return data
    
    def verify_solution_graphs(self, gamma0, sol_index=0, method=1):
        """ Function that plot boundary information to verify solution. Method 1 verifies u+zi.gama.n.grad(u)=Ui,
        Method 2 boundary gamma.n.grad(u) and Method 3 boundary gamma.n.grad(u) (only gaps)

    :param sol_index: Index for solution, 0 to l.
    :type sol_index: int
    :param method: 1, 2 or 3
    :type method: int
    
    :returns:  array -- Plot boundary.

    :Example:
    
    .. code-block:: python
    
        data = DirectProblem.verify_solution_graphs(sol_index=0, method=2)

        """
        


        mesh=self.mesh
        n = FacetNormal(mesh)
        u=self.sol_u[sol_index]
        de=self.de
        z=self.z

        VDG=FiniteElement('DG',mesh.ufl_cell(),0)
        Q=FunctionSpace(mesh,VDG)
        p, q = TrialFunction(Q), TestFunction(Q)
        M = assemble(inner(p, q)*ds)
        
        if method==1: L0 = inner(u+z[0]*inner(n,gamma0*grad(u)), q)*ds
        elif method==2: L0 = inner(inner(n,gamma0*grad(u)), q)*ds
        elif method==3: 
            M=assemble(inner(p, q)*de(0))
            L0 = inner(inner(n,gamma0*grad(u)), q)*de(0)
        
        b = assemble(L0)
        grad_u0 = Function(Q)
        x0 = grad_u0.vector()
        solve(M, x0, b)

        u_data =getBoundaryVertex(mesh, grad_u0);
        
        if method==1: name_='boundary u+zi.gama.n.grad(u)=Ui'
        elif method==2: name_='boundary gamma.n.grad(u)'
        elif method==3: name_='boundary gamma.n.grad(u) (only gaps)'
            
        data=plot_boundary(mesh, data=u_data, name=name_, line=0);
        return data

    def verify_solution_values(self, I_all, gamma0, sol_index=0, method=1):
        """ Function that plot boundary information to verify solution.

    :param sol_index: Index for solution, 0 to l.
    :type sol_index: int
    :param method: 1-Current Value, 2- Average potential on electrodes.
    :type method: int
    
    :returns:  array -- values.

    :Example:
    
    .. code-block:: python
    
        data = DirectProblem.verify_solution_graphs(sol_index=0, method=2)

        """

        set_log_level(50)
        mesh=self.mesh
        n = FacetNormal(mesh)
        u=self.sol_u[sol_index]
        list_U0=self.sol_U[sol_index].vector()
        grad_u = grad(u)
        de=self.de
        z=self.z

        n = FacetNormal(mesh)
        sum0=0

        if not isinstance(I_all[0],float) or isinstance(I_all[0],int): I=I_all[0]
        else: I=I_all
        
        if method==1:
            print("Current values")
            for i in range(len(I)):
                integral=assemble(inner(n,gamma0*grad_u)*de(i+1))
                print("Calculated:", round(integral,4), "Expected:", I[i])
                sum0+=integral

            print("Soma das correntes calculada: ", sum0)
        elif method==2:
            #Average value potencial electrode.
            print("Potential values")
            for i in range(len(I)):
                integral1=assemble(inner(n,gamma0*grad_u)*de(i+1))*z[i]
                integral2=assemble(u*de(i+1))
                integral=(integral1+integral2)/self.ele_size[i]
                print("Calculated:", round(integral,5), "Expected:", round(list_U0[i],5))
        return
    
    



    
 
import copy

class InverseProblem(ForwardProblem):
    """Inverse Object EIT 2D 
    
    :param mesh: Any mesh from Fenics module. We recommend from :func:`MyMesh()`
    :type mesh: mesh
    :param z:  Vector of impedances in electrodes
    :type z: array
    :param data: Vector with potencial in electrodes or any other vector.
    :type data: array
    :param I_all: Current density in each electrode for each measurement
    :type I_all: :func:`current_method()` or list of arrays
    
    :Example:
    
    >>> InverseObject=InverseProblem(mesh_inverse, list_U0_noised, I_all, z)
    >>> InverseObject.solve_inverse()
    >>> gamma_k=InverseObject.gamma_k

    """
    
    def __init__(self, mesh, data, I_all, z=None, select_pot_method=0):
        super().__init__(mesh, z)
        #"Basic definitions"
        self.mesh=mesh
        self.V=FiniteElement('CG',mesh.ufl_cell(),1)  #Function Space CG degree 1 is necessary.
        self.Q_DG = FunctionSpace(self.mesh, "DG", 0)
        self.I=I_all          #Current pattern used in generated data.
        self.list_U0=data     #electrodes Potencial in array
        self.select_pot_method=select_pot_method  #Method select potencial in the array. 0 - None, 1- Select method
        #Verify if is a matrix or a simply vector
        self.I=np.array(self.I)
        if self.I.ndim==2:
            self.l=len(self.I)
        else: self.l=1

        #"First guess and weight functions"
        self.firstguess=np.ones(mesh.num_cells())           #First guess for Forwardproblem
        self.Cellsgamma_k=np.array(self.firstguess)                       #Solution in array.
        self.gamma_k = Function(self.Q_DG)
        self.gamma_k.vector()[:]=self.Cellsgamma_k
        self.weight=np.ones(mesh.num_cells())             #Initial weight function
        
        #"Solver configurations"
        self.weight_value=True    #Are you going to use the weight function in the Jacobian matrix?
        self.step_limit=30        #Step limit while solve
        self.innerstep_limit=1000 #Inner step limit while solve
        self.min_v=1E-3           #Minimal value in element for gamma_k
        
        #"Noise Configuration"
        self.noise_level=0      #Noise_level from data (%) Ex: 0.01 = 1%
        self.tau=1.01           #Tau for disprance principle, tau>1
        
        #"Newton parameters"
        self.mu_i=0.9       #Mu initial (0,1]
        self.mumax=0.999    #Mu max
        self.nu=0.99        #Decrease last mu_n
        self.R=0.98         #Maximal decrease (%) for mu_n
        
        #"Inner parameters"
        self.inner_method='Landweber'  # Default inner method for solve Newton
        
        #Other Default parameters
        self.land_a=1    #Step-size Landweber
        self.ME_reg=5E-4 #Regularization Minimal Error
        self.Tik_c0=1    #Regularization parameter Iterative Tikhonov
        self.Tik_q=0.95  #Regularization parameter Iterative Tikhonov
        self.LM_c0=1     #Regularization parameter Levenberg-Marquadt
        self.LM_q=0.95   #Regularization parameter Levenberg-Marquadt
        
        #"A priori information"
        self.gamma0=None  #Exact Solution
        self.mesh0=None   #Mesh of exact solution
        
        #Creating a vector with all cell volumes. It's usefull for integrals in L2(Omega).
        cell_vec=[]
        for cell in cells(mesh):
            cell_vec.append(cell.volume())
        self.cell_vec=np.array(cell_vec)
        
        #Make a vector with electrodes size that are chosen for the problem
        #This vector is used in norm_L2(dOmega)
        self.size_elec_vec=self.select_potential(np.tile(self.ele_size, self.l), method=select_pot_method)
        
                #Banach Spaces parameters
        #Obs: Here we have several variables that we are working yet.
        self.Lp_space=2 #X, L_p space
        self.Lr_space=2 #Y, L_r space
    def solve_inverse(self):
        """Function that solves the inverse problem.
        
        :Example:
        
        >>> InverseObject=InverseProblem(mesh_inverse, list_U0_noised, I_all, z, select_pot_method=0)
        >>> InverseObject.solve_inverse()

    """
        "Creating basic informations."
        res_vec, error_vec=[], [] #To save about iterations
        self.innerstep_vec=[]     #Save inner_step newton
        mun_vec=[]                #Save mu in inner_step newton     
        gamma_all=np.array([])    #Saving all gamma_k
        self.steps=0              #Save external step.
        r=self.Lr_space #Data space L^r

        ##############################################
        "First Forward solver"
        self.list_u , self.list_U= self.solve_forward(self.V, self.I, self.gamma_k)
        self.list_U=np.array(self.list_U).flatten() #Convert to array
        self.list_U=self.select_potential(self.list_U, method=self.select_pot_method)
        b0 = self.list_U0-self.list_U #Define vector b0 (Ask=b0)
        
        "First Save data"
        #Residue vector
        res_vec.append(self.norm_funcL2(b0,           'dOmega', r)/
                       self.norm_funcL2(self.list_U0, 'dOmega', r)*100)
        self.innerstep_vec.append(int(0)) #Save inner number steps
        mun_vec.append(0)                 #Save number steps
        
        "Print information"
        if self.mesh0 is not None and self.gamma0 is not None:
            error_vec.append(self.error_gamma())    
            print("Error (%)=", error_vec[0], "Residue (%)=", res_vec[0], " step:", 0, "Inner step: ", 0)
        else:
            print("Residue (%)=", res_vec[0], " step:", 0, "Inner step: ", 0)
            
        "Solver"
        ##############################################
        #While discepancy or limit steps.
        while res_vec[self.steps]/100>=self.tau*self.noise_level and self.steps<self.step_limit:
            
            "Inner iteration newton"
            Jacobiana_all=self.Jacobian_calc()        #Derivative matrix calc
            sk, inner_step, mu=self.solve_innerNewton(Jacobiana_all, b0)
            self.Cellsgamma_k+=sk #Add a correction in each element
            
            #Don't have values less than c.s
            self.Cellsgamma_k[self.Cellsgamma_k < self.min_v] = self.min_v
            self.gamma_k.vector()[:]=self.Cellsgamma_k
            
            
            "Forward solver"
            self.list_u , self.list_U= self.solve_forward(self.V, self.I, self.gamma_k)
            self.list_U=np.array(self.list_U).flatten() #Convert to array
            self.list_U=self.select_potential(self.list_U, method=self.select_pot_method)
            b0 = self.list_U0-self.list_U #Define vector b0 (Ask=b0)
            
            "Saving data"
            #Saving gamma.
            if self.steps==0: gamma_all=np.array(self.Cellsgamma_k)
            else:  gamma_all=np.vstack((gamma_all, (np.array(self.Cellsgamma_k))))
                
            #Append residuo
            res_vec.append(self.norm_funcL2(b0,           'dOmega', r)/
                           self.norm_funcL2(self.list_U0, 'dOmega', r)*100)
            
            self.innerstep_vec.append(int(inner_step)) #Save number steps
            mun_vec.append(mu)                         #Save number steps
            
            #If we have exact solution, save error.
            if self.mesh0 is not None and self.gamma0 is not None:
                error_vec.append(self.error_gamma())
                
            self.steps+=1 #Next step.
            
            #Print information
            if self.mesh0 is not None and self.gamma0 is not None:
                print("Error (%)=", error_vec[self.steps], "Residue (%)=", res_vec[self.steps],
                      " step:", self.steps, "Inner step: ", inner_step)
            else: print("Residue (%)=", res_vec[self.steps],
                      " step:", self.steps, "Inner step: ", inner_step)
            ####################
            #Vectors to memory object.
            self.gamma_all=np.copy(gamma_all)
            self.res_vec=res_vec
            self.mun_vec=mun_vec
            self.error_vec=error_vec
            
        #############End-While############################
        return
   
        
    def solve_innerNewton(self, Jacobiana_all,b0):
        """Methods to solve inner step newton. Functions executed inside of :func:`solve_inverse()`. See set_InnerParameters() for more details.
            
    :param Jacobiana_all: Derivative Matrix generated by :func:`Jacobian_calc()`
    :type Jacobiana_all: Array ndim
    
    :returns:  (Array, int, float) -- Return a sk (Result of Inner Step to add in gamma_k), inner_step (Number of inner steps), mu (Regularization parameter used in the method).
            """
        
        #If weight True and step=0, determine the weight.
        if self.weight_value and self.steps==0: self.weight_func(Jacobiana_all) 
            
        ADJ=(Jacobiana_all*1/self.weight).T #Add weight.
        norm_b0=self.norm_funcL2(b0, 'dOmega', self.Lr_space)
        residuo=-b0            #Define res.
        norm_res=norm_b0       #Define norm_res first step.
        
        mu = self.newton_reg() #Calculate regularation parameter.
        inner_step=0
        
        sk=np.zeros(self.mesh.num_cells()) #s0 inicial do newton
        
        "------Landweber------"
        if self.inner_method=='Landweber':
            while norm_res>=mu*norm_b0 and inner_step<self.innerstep_limit:
                sk+=-self.land_a*ADJ@residuo

                residuo=-b0+Jacobiana_all@sk
                norm_res = self.norm_funcL2(residuo, 'dOmega')
                inner_step+=1
                
            "------Minimal Error------"
        elif self.inner_method=='ME' :
            while norm_res>=mu*norm_b0 and inner_step<self.innerstep_limit:
                sk_n=-ADJ@residuo
                omega=self.norm_funcL2(residuo, 'dOmega')**2/self.norm_funcL2(sk_n, 'Omega')**2*self.ME_reg
                sk+=omega*sk_n

                residuo=-b0+Jacobiana_all@sk
                norm_res = self.norm_funcL2(residuo, 'dOmega')
                inner_step+=1
        
            "------Conjugate-Gradient------"
        elif self.inner_method=='CG' :
            while norm_res>=mu*norm_b0 and inner_step<self.innerstep_limit:
                if inner_step==0:
                    rk=b0
                    ak=ADJ@rk
                    pk=ak
                    ak_old=ak                    

                qk=Jacobiana_all@pk
                alphak=(self.norm_funcL2(ak_old, 'Omega')**2)/(self.norm_funcL2(qk, 'dOmega')**2)
                sk=sk+alphak*pk
                rk=rk-alphak*qk
                ak=ADJ@rk
                betak=(self.norm_funcL2(ak, 'Omega')**2)/(self.norm_funcL2(ak_old, 'Omega')**2)
                pk=ak+betak*pk

                ak_old=ak
                residuo=-b0+Jacobiana_all@sk
                norm_res = self.norm_funcL2(residuo, 'dOmega')
                inner_step+=1
                

                
            "------Iterative Tikhonov------"
        elif self.inner_method=='Tikhonov':
            square_m0=ADJ@Jacobiana_all
            while norm_res>=mu*norm_b0 and inner_step<self.innerstep_limit:
                alpha_k=self.Tik_c0*(self.Tik_q**inner_step)
                square_m=square_m0+alpha_k*np.identity(np.size(square_m0, axis=0))
                sk+=np.linalg.solve(square_m, ADJ.dot(b0-Jacobiana_all@sk)) #Verificar com fab


                residuo=-b0+Jacobiana_all@sk
                norm_res = self.norm_funcL2(residuo, 'dOmega')
                inner_step+=1
                
            "------Levenberg-Marquadt------"
        elif self.inner_method=='LM':
            square_m0=ADJ@Jacobiana_all
            while norm_res>=mu*norm_b0 and inner_step<self.innerstep_limit:
                alpha_k=self.LM_c0*(self.LM_q**inner_step)
                square_m=square_m0+alpha_k*np.identity(np.size(square_m0, axis=0))
                sk=np.linalg.solve(square_m, ADJ.dot(b0))

                residuo=-b0+Jacobiana_all@sk
                norm_res = self.norm_funcL2(residuo, 'dOmega')
                inner_step+=1   
                

        return sk, inner_step, mu
        
    def Jacobian_calc(self):
        """Calcuate derivative matrix. Function executed inside of :func:`solve_inverse()`.
        
        :returns:  (Array ndim) -- Return the derivative matrix.        
              """
        BU_save=[] #Save potential electrodes
        bu_save=[] #Save potential domain
        list_u=self.list_u           #Get potential domain list
        
        
        
        #Construction new current pattern for Jacobian calc.
        #Ref: https://fabiomargotti.paginas.ufsc.br/files/2017/12/Margotti_Fabio-3.pdf chap 5.2.1
        I2_all=[]  #We will use to construct a smart way to calc. Jacobian
        for i in range(self.L):
            #I2_i=1 at electrode i and zero otherwise
            I2=np.zeros(self.L)
            I2[i]=1
            I2_all.append(I2)
        
        bu,BU=self.solve_forward(self.V, I2_all, self.gamma_k)
        bu_save=bu
        
        
        #separating electrodes data
        select_data=np.tile(range(0,self.L), self.l)
        select_data=self.select_potential(select_data, method=self.select_pot_method)
        select_data = np.split(select_data, np.where(select_data[:-1] == self.L-1)[0]+1)
        
        Q_DG = VectorFunctionSpace(self.mesh, "DG", 0, dim=2)
        list_grad_u = [project(grad(u), Q_DG).vector()[:].reshape(-1, 2) for u in list_u]
        list_grad_bu = [project(grad(bu), Q_DG).vector()[:].reshape(-1, 2) for bu in bu_save]      

        for h in range(self.l): #For each experiment
            derivada=[]
            for j in select_data[h]: #for each electrode
                derivada.append(-1*np.sum(list_grad_bu[j]*list_grad_u[h], axis=1)) #Get the function value in eache element
                
            Jacobiana=derivada*self.cell_vec #Matrix * Volume_cell
            if h==0: Jacobiana_all=Jacobiana #Append all jacs.
            else: Jacobiana_all=np.concatenate((Jacobiana_all, Jacobiana), axis=0)
                
        return Jacobiana_all
    
    def weight_func(self, Jacobiana):
        """Determine the weights for Derivative Matrix and apply.
        
        :param Jacobiana: Derivative Matrix generated by :func:`Jacobian_calc()`
        :type Jacobiana: Array ndim
    
        :returns:  (Array ndim) -- Return the derivative matrix with weights.
        
        """
        p=self.Lp_space
        #norm(Jacobian_line)*1/vol_cell_k*1/gamma_cell_k
        self.weight=np.linalg.norm(Jacobiana, ord=p, axis=0)*(1/self.cell_vec)*(1/self.Cellsgamma_k)
        return self.weight
    
    def newton_reg(self):
        """Determine the regulazation parameter for the Newton innerstep in :func:`solve_innerNewton()`."""
        #ref: https://doi.org/10.1137/040604029
        passo=self.steps
        innerstep_vec=self.innerstep_vec
        
        if passo>1:
            if innerstep_vec[passo-1]>=innerstep_vec[passo-2]: #If inner step increase
                mu_n=1-((innerstep_vec[passo-1]/innerstep_vec[passo])*(1-self.mu))
            else: mu_n=self.nu*self.mu #Remmember, nu<1.
            mu=self.mumax*np.amax([self.R*self.mu, mu_n]) #R limits how much the mu_n change.
        else: mu=self.mu_i #For the two first steps.
        
        self.mu=mu
        print("mu_n", mu)
        return mu
    
    def norm_funcL2(self, vector, domain, p=2):
        """This function is used in inner step of newton to calculate the norm's in L2 Omega and dOmega
         
        :param domain: 'Omega' or 'dOmega'.
        :type domain: str
        
        :returns:  (float) -- Return norm.
        
        """
        mesh=self.mesh
        weight=self.weight
        if domain=='Omega':
            norm=sum(abs(vector)**p*self.cell_vec*weight)
        elif domain=="dOmega":
            norm=sum(abs(vector)**p*self.size_elec_vec)

        norm=norm**(1/p)
        return norm
    
    def error_gamma(self):
        """Percentual error in L2 of the exact and reached solution for gamma.
        To works need use :func:`set_answer()`."""
        V0=FiniteElement('DG',self.mesh.ufl_cell(),0)
        V1=FiniteElement('DG',self.mesh0.ufl_cell(),0)
        
        Q0=FunctionSpace(self.mesh0, V0)
        Q1=FunctionSpace(self.mesh, V1)
        
        GammaElement0=interpolate(self.gamma0, Q0) #Interpolate to mesh_forward
        GammaElement1=interpolate(self.gamma_k, Q1) #interpolate gamma_k to mesh_inverse
        GammaElement1=interpolate(GammaElement1, Q0)#Interpolate from mesh_inverse to mesh_forward
        
        error_L2 = errornorm(GammaElement0, GammaElement1, 'L2') #Error norm
        norm_gamma0 = norm(GammaElement0, 'L2')                  #Norm exact solution
        GammaError=error_L2/norm_gamma0*100                      #percentual.
        
        if self.steps<=1:
            cell_vec0=[]
            for cell in cells(self.mesh0): cell_vec0.append(cell.volume())
            self.cell_vec0=np.array(cell_vec0)        
        
        #A way to calculated the error in a different norm.
        if self.Lp_space!=2:
            #Error norm
            error_Lp=sum(abs((np.array(GammaElement1.vector())-np.array(GammaElement0.vector())))**self.Lp_space*self.cell_vec0 )
            error_Lp=error_Lp**(1/self.Lp_space)
            #Exact norm
            norm_gamma0_Lp=sum(abs((np.array(np.array(GammaElement0.vector())))**self.Lp_space*self.cell_vec0 ))
            norm_gamma0_Lp=norm_gamma0_Lp**(1/self.Lp_space)
            
            GammaError_Lp= error_Lp/norm_gamma0_Lp*100 #Percentual
        #print(GammaError_Lp)
        
        return GammaError
    
    def set_answer(self, gamma0, mesh0):
        """"Get and set the answer if we have it.
        It is usefull to determine the best solution reached.
        :func:`error_gamma()` will return you the percentual error in L2. 
        
        :param mesh0: Any mesh from Fenics module. We recommend from :func:`MyMesh()`
        :type mesh0: mesh
        :param gamma0: Finite Element Function
        :type gamma0: :func:`CellFunction()`
        
         :Example:

         >>> InverseObject=InverseProblem(mesh_inverse, list_U0_noised, I_all, z)
         >>> InverseObject.set_answer(gamma0, mesh_direct)
        
        """
        self.gamma0=gamma0
        self.mesh0=mesh0
        return
    
    def set_NewtonParameters(self,  **kwargs):
        """Newton Parameters
        
            Kwargs:
               * **mu_i** (float): Mu initial (0,1]
               * **mumax** (float): mumax (0,1]
               * **nu**    (float): Decrease last mu_n
               * **R**     (float): Minimal value for mu_n
        
            Default Parameters:
                >>> self.mu_i=0.9      
                >>> self.mumax=0.999   
                >>> self.nu=0.99       
                >>> self.R=0.9         
                
                :Example:

                >>> InverseObject=InverseProblem(mesh_inverse, list_U0_noised, I_all, l, z)
                >>> InverseObject.set_NewtonParameters(mu_i=0.90, mumax=0.999, nu=0.985, R=0.90)
        """        
        for arg in kwargs:
            setattr(self, arg, kwargs[arg])
        return
        
    def set_NoiseParameters(self, tau, noise_level):
        """Noise Parameters to stop with Discrepancy Principle.

            :param tau: Tau for disprance principle [0, \infty)
            :type tau: float
            :param noise_level: Noise_level(%) from data [0,1)
            :type noise_level: float

            Default Parameters:
                >>> self.tau=0      
                >>> self.noise_level=0   
                
            :Example:

            >>> InverseObject=InverseProblem(mesh_inverse, list_U0_noised, I_all, l, z)
            >>> InverseObject.set_NoiseParameters(tau=5, noise_level=0.01)
        """
        self.tau=tau
        self.noise_level=noise_level
        
    def set_firstguess(self, Cellsgamma_k):
        """ Default parameters for first guess in external step newton.
       
            :param Cellsgamma_k: We expect a vector that represents the value of gamma in your cell.
            :type Cellsgamma_k: array
            
            Default Parameters:
                >>> self.Cellsgamma_k=np.ones(self.mesh.num_cells())*0.9      
                
            :Example:

            >>> InverseObject=InverseProblem(mesh_inverse, list_U0_noised, I_all, l, z)
            >>> InverseObject.set_firstguess(np.ones(mesh_inverse.num_cells())*5)
            
        """
        self.firstguess=Cellsgamma_k           #First guess for Forwardproblem
        self.Cellsgamma_k=self.firstguess           
        self.gamma_k.vector()[:]=self.Cellsgamma_k #Guess in cell function """
        
    def set_solverconfig(self, **kwargs):
        """Solver config.
        
            Kwargs:
               * **weight_value** (bool): Weight function in Jacobian matrix
               * **step_limit** (float): Step limit while solve
               * **min_v**    (float): Minimal value in element for gamma_k             
        
            Default Parameters:       
               >>> self.weight_value=True  
               >>> self.step_limit=5       
               >>> self.min_v=0.05         
                
            :Example:

            >>> InverseObject=InverseProblem(mesh_inverse, list_U0_noised, I_all, l, z)
            >>> InverseObject.set_solverconfig(weight_value=True, step_limit=200, min_v=0.01)
            
        """       
        for arg in kwargs:
            setattr(self, arg, kwargs[arg])

    def set_InnerParameters(self, **kwargs):
        """Inner-step Newton Parameters
        
            Kwargs:
               * **inner_method** (str): Method to solver inner step newton. Options: 'Landweber', 'CG', 'ME', 'LM', 'Tikhonov'
               * **land_a**       (int): Step-size Landweber
               * **ME_reg**     (float): Minimal value in element for gamma_k             
               * **Tik_c0**     (float): Regularization parameter Iterative Tikhonov
               * **Tik_q**      (float): Regularization parameter Iterative Tikhonov
               * **LM_c0**     (float): Regularization parameter Levenberg-Marquadt
               * **LM_q**       (float): Regularization parameter Levenberg-Marquadt
        
            Default Parameters:
               >>> self.inner_method='Landweber'
               >>> self.land_a=1    
               >>> self.ME_reg=5E-4 
               >>> self.Tik_c0=1    
               >>> self.Tik_q=0.95  
               >>> self.LM_c0=1     
               >>> self.LM_q=0.95   

            :Example:

            >>> InverseObject=InverseProblem(mesh_inverse, list_U0_noised, I_all, l, z)
            >>> InverseObject.set_InnerParameters(inner_method='ME', ME_reg=5E-4)i
            
        """
        for arg in kwargs:
            setattr(self, arg, kwargs[arg])

import matplotlib.pyplot as plt
from matplotlib.patches import Wedge,Arc

def plot_figure(function, name, save=False, map='inferno'):
    plt.figure()
    p=plot(function, title=name)
    p.set_cmap(map)
    #p.set_clim(0.0, 4.0)
    plt.colorbar(p)
    if save==True: plt.savefig(name)
    return 



def getBoundaryVertex(mesh,u):
    u_bvertex=[]
    u_bvertex_ind=[]
    bmesh=BoundaryMesh(mesh, 'exterior', order=True)
    indice_borda=bmesh.entity_map(0).array()
    
    for ind in indice_borda:
        u_bvertex.append(u.compute_vertex_values()[ind]) #pra pegar os valores, apenas na borda, como array
    return u_bvertex


def plot_boundary(mesh, data, name='boundary', line=2, data2=1, save=False, plot=True):
    tol=0.0
    bmesh=BoundaryMesh(mesh, 'exterior', order=True)
    indice_borda=bmesh.entity_map(0).array()
    boundary_plot1, boundary_plot2=[], []
    for ind in range(len(indice_borda)):
        vertex = Vertex(mesh, indice_borda[ind])
        if vertex.x(1)>=tol:
            theta=np.arccos(vertex.x(0))
            boundary_plot1.append([theta, data[ind]])
    boundary_plot1=np.array(boundary_plot1)
    max_b=np.max(boundary_plot1[:,0])        

    
    for ind in range(len(indice_borda)):
        vertex = Vertex(mesh, indice_borda[ind])    
        if vertex.x(1)<0:
            theta=np.arccos(-vertex.x(0))+max_b
            boundary_plot2.append([theta, data[ind]])
    
    boundary_plot=np.concatenate((boundary_plot1, boundary_plot2), axis=0)
    
    
    boundary_plot=boundary_plot[boundary_plot[:,0].argsort()]
    #boundary_plot=np.sort(boundary_plot.view('i8'), order=['f1'], axis=0)

    if plot==True:
        plt.figure()
        plt.title(name)
        if type(data2)!=type(1):
            plt.plot(data2[:,0], data2[:,1], marker='.', markersize=2, linewidth=line, label="Dados")    
        plt.plot(boundary_plot[:,0], boundary_plot[:,1], marker='.', markersize=2, linewidth=line, label="Resultado")
        #plt.legend()
        if save==True: plt.savefig(name)
    
    return boundary_plot

def plot_electrodes(mesh, linewidth_mesh = 1, linewidth_elec=5, figsize=(5,5), fontsize=20, elec_num=True, axis=False):
    """
    Plot the electrodes on a mesh.

    :param mesh: A mesh object.
    :type mesh: Mesh
    :param linewidth: The width of the electrode lines (default 5).
    :type linewidth: int
    :param figsize: The size of the figure (default (5,5)).
    :type figsize: tuple
    :param fontsize: The font size of the electrode numbers (default 20).
    :type fontsize: int
    :param elec_num: Whether to show electrode numbers (default True).
    :type elec_num: bool
    :param axis: Whether to show the axis (default False).
    :type axis: bool
    :returns: The figure object.
    :rtype: matplotlib.figure.Figure
    """

    fig, ax = plt.subplots(figsize=figsize)
    mesh_radius = mesh.radius
    theta_vec = np.degrees(np.array(mesh.electrodes.position))

    for index, theta in enumerate(theta_vec):
        theta_start, theta_end = theta[0], theta[1]
        centertheta = (abs(theta_start-theta_end)/2+theta_start)/360*(2*np.pi)
        #Plotting arc
        arc = Arc((0, 0), 2 * mesh_radius * 1.01, 2 * mesh_radius * 1.01, angle=0,
                theta1=theta_start, theta2=theta_end, linewidth=linewidth_elec, color='black')
        #Plotting Electrode number
        if elec_num:
            x, y = mesh_radius*np.cos(centertheta)*1.1, mesh_radius*np.sin(centertheta)*1.1
            ax.annotate(index+1, (x, y), color='black', weight='bold', fontsize=fontsize, ha='center', va='center')
        ax.add_artist(arc)

    ax.set_aspect(1)
    plot(mesh, linewidth=linewidth_mesh)
    
    if not axis:
        plt.xticks([])
        plt.yticks([])
        plt.box(False)
    return 


def EstimateDelta(list_U_noised: np.ndarray, I: np.ndarray) -> float:
    """
    Estimate the noise level in potential measurements obtained from a grounded electrode system. The method was based on 
     Robert Winkler work: A model-aware inexact Newton scheme for electrical impedance tomography, 2016.

    :param list_U_noised: A 1D numpy array of length l * L containing the potential measurements with noise.
    :type list_U_noised: numpy.ndarray
    :param I: A 2D numpy array of shape (l, L) containing the injection pattern matrix with l electrodes and L measurements.
    :type I: numpy.ndarray

    :return: A scalar value representing the estimated noise level in the potential measurements.
    :rtype: float

    :notes:
        The data must be measured through a grounded electrode, i.e., the sum of potential of each of the electrodes must be zero.

    This function estimates the noise level in potential measurements obtained from a grounded electrode system. It takes two
    arguments as inputs: `list_U_noised` and `I`.
    """
    l, L = np.shape(I)
    list_U_noised = list_U_noised.reshape((l, L))
    Iplus = np.linalg.pinv(I)

    ev = (Iplus @ list_U_noised) - (Iplus @ list_U_noised).T
    norm_ev = np.linalg.norm(ev, ord="fro") ** 2
    norm_Iplus = np.linalg.norm(Iplus, ord="fro")
    vCEM = norm_ev / (2 * (L - 1)) * norm_Iplus ** (-2)
    delta_calc = np.sqrt(l * L * vCEM)

    return delta_calc

def ConvertingData(U,method):
    """
    Convert data from different measurement patterns to the ground pattern.

    :param A: The data to be converted.
    :type A: numpy.ndarray
    :param method: The measurement pattern to be converted to. Currently only "KIT4" is supported.
    :type method: str
    :return: The converted data.
    :rtype: numpy.ndarray
    """
    if method=="KIT4": 
        #See: https://arxiv.org/pdf/1704.01178.pdf
        L=len(U)
        U_til = np.zeros(L)
        for i in range(1,L): U_til[i]=np.sum(U[:i])
        c = np.sum(U_til)
        return c/L-U_til
    return U

def EstimateCond(list_U0, I, mesh, z, method="CONT"):
    """
    Estimate the conductivity of the background based on noisy voltage measurements.

    :param list_U0: A list of noisy voltage measurements.
    :type list_U0: list
    :param I: A current source matrix.
    :type I: numpy.ndarray
    :param mesh: A mesh object.
    :type mesh: Mesh
    :param z: The background impedance (default 1E-5).
    :type z: numpy.ndarray
    :param method: Method: CONT, SHUNT, CEM1, CEM2
    :type method: str
    :return: A tuple of conductivity estimate and minimum potential.
    :rtype: tuple(float, float)
    """
    l, L = np.shape(I)
    gamma = Function(FunctionSpace(mesh, "DG", 0))
    gamma.vector()[:]=np.ones(mesh.num_cells())

    #Solver
    VD=FiniteElement('CG',mesh.ufl_cell(),1) #Solution Space Continous Galerkin
    ForwardObject=ForwardProblem(mesh,  z)
    _, list_U = ForwardObject.solve_forward(VD, I, gamma)

    list_U0 = np.array(list_U0).reshape(l,L)
    if method=="CONT":
        list_U=np.array(list_U).flatten()
        list_U0=np.array(list_U0).flatten()
        cond = np.linalg.norm(list_U)**2/np.dot(list_U, list_U0)
        return cond
    if method=="SHUNT":
        U_1=[np.dot(list_U[i],I[i]) for i in np.arange(l)]
        U_2=[np.dot(list_U0[i],I[i]) for i in np.arange(l)]
        cond=np.linalg.norm(U_1)**2/np.dot(U_1,U_2)
        return cond
    if method == "CEM1":
        z0=np.max(z)
        elec_lenght = mesh.radius*(mesh.electrodes.calc_position()[0][1]-mesh.electrodes.calc_position()[0][0])
        U_1=[np.dot(list_U[i]-I[i]*z0/elec_lenght,I[i]) for i in np.arange(l)]
        U_2=[np.dot(list_U0[i]-I[i]*z0/elec_lenght,I[i]) for i in np.arange(l)]
        cond=np.dot(U_1,U_2)/np.linalg.norm(U_2)**2
        return cond
    if method == "CEM2":
        z0=np.max(z)
        elec_lenght = mesh.radius*(mesh.electrodes.calc_position()[0][1]-mesh.electrodes.calc_position()[0][0])

        a_vec=[np.dot(list_U[i]-I[i]*z0/elec_lenght, I[i]) for i in np.arange(l)]
        b_vec=[np.dot(I[i],I[i]/elec_lenght) for i in np.arange(l)]
        c_vec = [np.dot(list_U0[i],I[i])for i in np.arange(l)]

        A = np.array([a_vec, b_vec]).T
        x0 = scipy.optimize.nnls(A, c_vec)
        rho, z = x0[0]
        cond = 1/rho
        return cond, z
    
def EstimateCondIterative(list_U0, I, mesh, z, zmin=1E-5):
    #Define the functional
    def fun(zi, list_U0, I, mesh, z):
        l, L = np.shape(I)
        cond, z = EstimateCond(list_U0, I, mesh, zi, method="CEM2")
        z=np.max([zmin, z])

        Q_DG=FunctionSpace(mesh, "DG", 0)
        gamma = Function(Q_DG)
        gamma.vector()[:]=np.ones(mesh.num_cells())*cond

        ForwardObject=ForwardProblem(mesh,  z*np.ones(L))
        VD=FiniteElement('CG',mesh.ufl_cell(),1) #Solution Space Continous Galerkin
        _, list_U = ForwardObject.solve_forward(VD, I, gamma)
        list_U = np.array(list_U).flatten()

        res = np.linalg.norm(list_U - list_U0)/np.linalg.norm(list_U0)*100
        #print(res)
        return  res
    
    data = scipy.optimize.minimize(fun, 1E-5, args=(list_U0, I, mesh, z))
    z_optimal=data['x']
    cond_optimal, z_optimal = EstimateCond(list_U0, I, mesh, z_optimal, method="CEM2")
    return cond_optimal, z_optimal
