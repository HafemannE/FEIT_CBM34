from mshr import*
import numpy as np
from fenics import*


class electrodes_position():    
    """Object that contains the position of the electrodes in boundary.
        The position is stored in function of angle theta initial and final of each electrode.
    
        :param L: Number electrodes.
        :type L: int.
        :param per_cober: Percentual covered lenght in boundary by electrodes, between 0 and 1. 
        :type per_cober: float.
        :param rotate: Rotation angle in the original solution for electrodes.
        :type rotate: float.
        
        :Example:
            >>> ele_pos=electrodes_position(L=16, per_cober=0.5, rotate=0)
            >>> print(ele_pos.position)
            [[0.0, 0.19634954084936207],
             [0.39269908169872414, 0.5890486225480862],
             [0.7853981633974483, 0.9817477042468103],
             [1.1780972450961724, 1.3744467859455345],
             [1.5707963267948966, 1.7671458676442586],
             ...,
             [5.890486225480862, 6.086835766330224]]
            
        """
    
    def __init__(self, L, per_cober, rotate, anticlockwise=True):
        #Checks
        if not isinstance(L, int): raise ValueError("Number of electrodes must be an integer.")
        if not isinstance(per_cober, float): raise ValueError("per_cober must be a float.")
        if not isinstance(rotate, (int, float)): raise ValueError("rotate must be a float.")
        if not isinstance(anticlockwise, bool): raise ValueError("anticlockwise must be true of false.")
        if per_cober>1: raise ValueError("per_cober must be equal or less than 1. Example (75%): per_cober=0.75 ")
        
        self.rotate=rotate
        self.L=L
        self.per_cober=per_cober
        self.anticlockwise=anticlockwise

        self.position=self.calc_position()
    
    
    def calc_position(self):
        """Calculate the position of electrodes based in :class:`electrodes_position()` object.
        
        :returns:  list of arrays -- Return list with angle initial and final of each electrode."""
        size_e=2*pi/self.L*self.per_cober       #Size electrodes
        size_gap=2*pi/self.L*(1-self.per_cober) #Size gaps
        rotate=self.rotate                      #Rotating original solution

        electrodes=[]
        for i in range(self.L):
            #Example electrodes=[[0, pi/4], [pi/2, pi]]
            electrodes.append([size_e*i+size_gap*i+rotate, size_e*(i+1)+size_gap*i+rotate]) #Grouping angular values for electrodes.
        if not self.anticlockwise:
            electrodes[1:] = electrodes[1:][::-1] #Keep first electrode and reverse order
        return electrodes

def MyMesh(r, n, n_in, n_out, electrodes_obj):
    """Function that generate the mesh based in the electrodes position

    :param r: Circle Radius
    :type r: float.
    :param n: Refinament parameter
    :type n: int.
    :param n_in: Vertices number in electrodes
    :type n_in: int
    :param n_out: Vertices number in gaps.
    :type n_out: int
    :param electrodes_obj: Object.
    :type electrodes_obj: :class:`electrodes_position()`

    :return: :class:`dolfin.cpp.mesh.Mesh`

    :Example:
            >>> ele_pos=electrodes_position(L=16, per_cober=0.5, rotate=0)
            >>> mesh_inverse=MyMesh(r=1, n=8, n_in=6, n_out=1, electrodes_obj=ele_pos)
            >>> mesh_forward=MyMesh(r=1, n=8*3, n_in=6*3, n_out=1*3, electrodes_obj=ele_pos)

    .. image:: codes/mesh.png
      :scale: 75 %

    """

    electrodes=np.copy(electrodes_obj.position)
    L=electrodes_obj.L
    rotate=electrodes_obj.rotate
    anticlockwise= electrodes_obj.anticlockwise
    
    if not isinstance(r, (int, float)): raise ValueError("radius must be a float or an integer.")
    if not isinstance(n, (int, float)): raise ValueError("n must be a float or an integer.")
    #if not isinstance(n_in, int): raise ValueError("Vertices number in electrodes must be integer or an array of integers.")
    #if not isinstance(n_out, int): raise ValueError("Vertices number in gaps must be integer or an array of integers.")
    if not isinstance(electrodes_obj, electrodes_position): raise Exception("Electrodes_obj must be generated by electrodes_position().")
 
    

    if isinstance(n_in, int): n_in=np.ones(L)*n_in
    if isinstance(n_out, int): n_out=np.ones(L+L)*n_out


    ###Points Generator###
    points=[]
    save_points=[]
    save_vertex=[]
    save_vertex_elec=[]
    if not anticlockwise:  electrodes[1:] = electrodes[1:][::-1] #Fenics only accepts anticlockwise
    for i in range(L):
        save_vertex=[]
        #Creating vertex on the electrodes.
        theta0, thetai= electrodes[i][0], electrodes[i][1]
        for theta in np.linspace(theta0, thetai, int(n_in[i])):
            a=[Point((cos(theta)*r,sin(theta)*r))]     #Defining Point object from Fenics.
            points=np.concatenate((points,a), axis=0)  #Grouping points.
            vertex_cord=[cos(theta)*r,sin(theta)*r]    #Creating elec vertex on the boundary in anti-clockwise.
            save_vertex.append(vertex_cord)            #Grouping vertex positions in R2

        #Selecting the last gap with the first electrode.
        if i<L-1: theta0, thetai= electrodes[i][1], electrodes[i+1][0]
        else: theta0, thetai= electrodes[i][1], 2*pi+rotate
        
        #Creating vertex on the gaps.
        for theta in np.linspace(theta0, thetai, int(n_out[i])+2):
            if theta!=theta0 and theta!=thetai:
                a=[Point((cos(theta)*r,sin(theta)*r))]    #Creating gap vertex on the boundary in anti-clockwise.
                points=np.concatenate((points,a), axis=0) #Grouping points.
        
        save_vertex_elec.append(save_vertex) #Grouping list of vertex in the electrode i.

    if not anticlockwise:  
        save_vertex_elec[1:] = save_vertex_elec[1:][::-1] #Pass vertex in clockwise pattern

    domain = Polygon(points)          #Function creates a polygon with the points.
    mesh = generate_mesh(domain,n)    #Get the polygon and generate the mesh
    mesh.radius=r                     #Information input in the mesh.
    mesh.vertex_elec=save_vertex_elec #Pass the vertex position of the electrodes to the object memory. It will be used in fowward problem.
    mesh.electrodes=electrodes_obj   #Pass the electrodes object to mesh
    return mesh