from mshr import*
import numpy as np
from fenics import*


class electrodes_position():    
    """
    Object that contains the position of the electrodes in the boundary.
    The position is stored as the initial and final angles of each electrode.

    :param L: Number of electrodes.
    :type L: int
    :param per_cober: Percentual covered length in the boundary by electrodes, between 0 and 1.
    :type per_cober: float
    :param rotate: Rotation angle in the original solution for electrodes (in radians).
    :type rotate: float
    :param anticlockwise: If True, the electrodes are positioned anticlockwise, else clockwise.
    :type anticlockwise: bool, optional (default is True)

    :Example:
        >>> ele_pos = electrodes_position(L=16, per_cober=0.5, rotate=0)
        >>> print(ele_pos.position)
        [[0.0, 0.19634954084936207],
         [0.39269908169872414, 0.5890486225480862],
         [0.7853981633974483, 0.9817477042468103],
         [1.1780972450961724, 1.3744467859455345],
         [1.5707963267948966, 1.7671458676442586],
         ...,
         [5.890486225480862, 6.086835766330224]]
    """
    
    def __init__(self, L, per_cober, rotate, anticlockwise=True):
        #Checks
        if not isinstance(L, int): raise ValueError("Number of electrodes must be an integer.")
        if not isinstance(per_cober, float): raise ValueError("per_cober must be a float.")
        if not isinstance(rotate, (int, float)): raise ValueError("rotate must be a float.")
        if not isinstance(anticlockwise, bool): raise ValueError("anticlockwise must be true of false.")
        if per_cober>1: raise ValueError("per_cober must be equal or less than 1. Example (75%): per_cober=0.75 ")
        
        self.rotate=rotate
        self.L=L
        self.per_cober=per_cober
        self.anticlockwise=anticlockwise

        self.position=self.calc_position()
    
    
    def calc_position(self):
        """
        Calculate the position of electrodes based on the :class:`electrodes_position` object.

        :returns: list of arrays -- Returns a list with angle initial and final of each electrode.
        """
        size_e=2*pi/self.L*self.per_cober       #Size electrodes
        size_gap=2*pi/self.L*(1-self.per_cober) #Size gaps
        rotate=self.rotate                      #Rotating original solution

        electrodes=[]
        for i in range(self.L):
            #Example electrodes=[[0, pi/4], [pi/2, pi]]
            electrodes.append([size_e*i+size_gap*i+rotate, size_e*(i+1)+size_gap*i+rotate]) #Grouping angular values for electrodes.
        if not self.anticlockwise:
            electrodes[1:] = electrodes[1:][::-1] #Keep first electrode and reverse order
        return electrodes

def MyMesh(r, n, n_in, n_out, electrodes_obj):
    """
    Function that generates the mesh based on the electrodes' position.

    :param r: Circle radius.
    :type r: float
    :param n: Refinement parameter.
    :type n: int
    :param n_in: Number of vertices on the electrodes.
    :type n_in: int or list[int]
    :param n_out: Number of vertices in gaps.
    :type n_out: int or list[int]
    :param electrodes_obj: Object containing the electrodes' positions.
    :type electrodes_obj: :class:`electrodes_position`

    :return: :class:`dolfin.cpp.mesh.Mesh`

    :Example:
        >>> #Generate a mesh for an inverse problem:
        >>> ele_pos = electrodes_position(L=16, per_cober=0.5, rotate=0)
        >>> mesh_inverse = MyMesh(r=1, n=8, n_in=6, n_out=1, electrodes_obj=ele_pos)
        >>> #Generate a mesh for generate data with increased refinement:
        >>> mesh_refined = MyMesh(r=1, n=8*3, n_in=6*3, n_out=1*3, electrodes_obj=ele_pos)

    The resulting mesh can be visualized with other tools.

    .. image:: codes/mesh.png
        :scale: 75 %
    
    """

    electrodes=np.copy(electrodes_obj.position)
    L=electrodes_obj.L
    rotate=electrodes_obj.rotate
    anticlockwise= electrodes_obj.anticlockwise
    
    if not isinstance(r, (int, float)): raise ValueError("radius must be a float or an integer.")
    if not isinstance(n, (int, float)): raise ValueError("n must be a float or an integer.")
    #if not isinstance(n_in, int): raise ValueError("Vertices number in electrodes must be integer or an array of integers.")
    #if not isinstance(n_out, int): raise ValueError("Vertices number in gaps must be integer or an array of integers.")
    if not isinstance(electrodes_obj, electrodes_position): raise Exception("Electrodes_obj must be generated by electrodes_position().")
 
    

    if isinstance(n_in, int): n_in=np.ones(L)*n_in
    if isinstance(n_out, int): n_out=np.ones(L+L)*n_out


    ###Points Generator###
    points=[]
    save_points=[]
    save_vertex=[]
    save_vertex_elec=[]
    if not anticlockwise:  electrodes[1:] = electrodes[1:][::-1] #Fenics only accepts anticlockwise
    for i in range(L):
        save_vertex=[]
        #Creating vertex on the electrodes.
        theta0, thetai= electrodes[i][0], electrodes[i][1]
        for theta in np.linspace(theta0, thetai, int(n_in[i])):
            a=[Point((cos(theta)*r,sin(theta)*r))]     #Defining Point object from Fenics.
            points=np.concatenate((points,a), axis=0)  #Grouping points.
            vertex_cord=[cos(theta)*r,sin(theta)*r]    #Creating elec vertex on the boundary in anti-clockwise.
            save_vertex.append(vertex_cord)            #Grouping vertex positions in R2

        #Selecting the last gap with the first electrode.
        if i<L-1: theta0, thetai= electrodes[i][1], electrodes[i+1][0]
        else: theta0, thetai= electrodes[i][1], 2*pi+rotate
        
        #Creating vertex on the gaps.
        for theta in np.linspace(theta0, thetai, int(n_out[i])+2):
            if theta!=theta0 and theta!=thetai:
                a=[Point((cos(theta)*r,sin(theta)*r))]    #Creating gap vertex on the boundary in anti-clockwise.
                points=np.concatenate((points,a), axis=0) #Grouping points.
        
        save_vertex_elec.append(save_vertex) #Grouping list of vertex in the electrode i.

    if not anticlockwise:  
        save_vertex_elec[1:] = save_vertex_elec[1:][::-1] #Pass vertex in clockwise pattern

    domain = Polygon(points)          #Function creates a polygon with the points.
    mesh = generate_mesh(domain,n)    #Get the polygon and generate the mesh
    mesh.radius=r                     #Information input in the mesh.
    mesh.vertex_elec=save_vertex_elec #Pass the vertex position of the electrodes to the object memory. It will be used in fowward problem.
    mesh.electrodes=electrodes_obj   #Pass the electrodes object to mesh
    return mesh

import scipy

def current_method(L,l, method=1, value=1):
    """
    Create a numpy array (or a list of arrays) that represents the current pattern in the electrodes.

    :param L: Number of electrodes.
    :type L: int
    :param l: Number of measurements.
    :type l: int
    :param method: Current pattern. Possible values are 1, 2, 3, or 4 (default=1).
    :type method: int
    :param value: Current density value (default=1).
    :type value: int or float

    :returns: list of arrays or numpy array -- Return list with current density in each electrode for each measurement.

    :Method Values:
        1. 1 and -1 in opposite electrodes.
        2. 1 and -1 in adjacent electrodes.
        3. 1 in one electrode and -1/(L-1) for the rest.
        4. For measurement k, we have: (sin(k*2*pi/16) sin(2*k*2*pi/16) ... sin(16*k*2*pi/16)).

    :Example:

    Create current pattern 1 with 4 measurements and 4 electrodes:

    >>> I_all = current_method(L=4, l=4, method=1)
    >>> print(I_all)
        [array([ 1.,  0., -1.,  0.]),
        array([ 0.,  1.,  0., -1.]),
        array([-1.,  0.,  1.,  0.]),
        array([ 0., -1.,  0.,  1.])]

    Create current pattern 2 with 4 measurements and 4 electrodes:

    >>> I_all = current_method(L=4, l=4, method=2)
    >>> print(I_all)
        [array([ 1., -1.,  0.,  0.]),
        array([ 0.,  1., -1.,  0.]),
        array([0.,  0.,  1., -1.]),
        array([ 1.,  0.,  0., -1.])]

    """
    I_all=[]
    #Type "(1,0,0,0,-1,0,0,0)"
    if method==1:
        if L%2!=0: raise Exception("L must be odd.")
                                   
        for i in range(l):
            if i<=L/2-1:
                I=np.zeros(L)
                I[i], I[i+int(L/2)]=value, -value
                I_all.append(I)
            elif i==L/2:
                print("This method only accept until L/2 currents, returning L/2 currents.")
    #Type "(1,-1,0,0...)"
    if method==2:
        for i in range(l):
            if i!=L-1:
                I=np.zeros(L)
                I[i], I[i+1]=value, -value
                I_all.append(I)
            else: 
                I=np.zeros(L)
                I[0], I[i]=-value, value
                I_all.append(I)
    #Type "(1,-1/15, -1/15, ....)"
    if method==3:
        for i in range(l):
            I=np.ones(L)*-value/(L-1)
            I[i]=value
            I_all.append(I)
    #Type "(sin(k*2*pi/16) sin(2*k*2*pi/16) ... sin(16*k*2*pi/16))"
    if method==4:
        for i in range(l):
            I=np.ones(L)
            for k in range(L): I[k]=I[k]*sin((i+1)*(k+1)*2*pi/L) 
            I_all.append(I)

            
    if l==1: I_all=I_all[0]
    return np.array(I_all)

def fn_addnoise(data, level, noise_type='uniform', seed=42):
    """
    Add noise to a vector representing data in the electrodes.

    :param data: Vector with potential in electrodes or any other vector.
    :type data: array_like
    :param level: Noise level (%), expects values between 0 and 1.
    :type level: float
    :param noise_type: Noise type, 'uniform' or 'cauchy' (default='uniform').
    :type noise_type: str
    :param seed: Seed for the random number generator (default=42).
    :type seed: int

    :returns: Array -- Return the noised vector.

    :Example:

    >>> data = np.ones(8)
    >>> print(data)
        [1. 1. 1. 1. 1. 1. 1. 1.]
    >>> noised_data = fn_addnoise(data=data, level=0.01, noise_type='cauchy', seed=32)
    >>> print(noised_data)
        array([0.99905327, 1.02206251, 1.00356633, 1.00236212, 1.00101231, 0.99904405, 1.0105611 , 0.98656216])
    """

    i = len(data)
    # create 1D numpy data:
    npdata = np.asarray(data).reshape((i))
    delta=level*np.linalg.norm(npdata) #delta = noise_level * ||data||_2
    
    #add f normal noise:
    if noise_type=='uniform':
        np.random.seed(seed)                             #Set seed to generate random noise
        noise_f=np.random.randn(npdata.size)             #Generate random noise with vector size of data.
        noise_f=noise_f/np.linalg.norm(noise_f)*delta    #Normalize random noise and multiply by delta.
        noise = npdata + noise_f                         #Add noise to the vector.
    # add cauchy noise:
    elif noise_type=='cauchy':   
    #12 31 59
        np.random.seed(seed)                                     #Set seed to generate random noise
        noise_p = np.random.standard_cauchy(size=npdata.shape)   #Generate random noise with vector size of data.
        noise_p=noise_p/np.linalg.norm(noise_p)*delta            #Normalize random noise and multiply by delta
        noise = npdata + noise_p                                 #Add noise to the vector.
        
    return noise

class electrode_domain(SubDomain):
    """
    Auxiliary function for the ForwardProblem to define an electrode domain.
    It is expected that the domain is a circle.
    This routine determines the vertices where the electrodes are defined and marks the mesh.
    We use it in :func:`ForwardProblem.electrodes`.

    :param mesh_vertex: Vertex coordinates of the electrode.
    :type mesh_vertex: array-like
    :param radius: Circle radius.
    :type radius: float
    :param L: Number of electrodes.
    :type L: int
    """
    def __init__(self, mesh_vertex, radius, L):   #Observe that mesh_vertex is from electrode i.
        super(electrode_domain, self).__init__()  #init subclass
        self.mesh_vertex=np.array(mesh_vertex).T  #Getting vertex electrodes from mesh.
        self.L=L                                  #Setting electrodes number.
        self.X=np.max(self.mesh_vertex[0])        #Max value axis x
        self.X1=np.min(self.mesh_vertex[0])       #Min value axis x 
        self.Y=np.max(self.mesh_vertex[1])        #Max value axis y
        self.Y1=np.min(self.mesh_vertex[1])       #Max value axis y
        
    def inside(self, x, on_boundary):  #Fenics functions that evals where is the Subdomain setting True os false on the vertex.
        #Here we implemented a strategy to verify if the vertex is part of electrode or nop.
        #Fenics get only vertex on boundary for us. After that we verify if the vertex is inside a "box" at (X1,X) x (Y1,Y).
        if on_boundary:  #If elemente is on boundary.
            #If vertex coordinate x are is bewteen...
            if between(x[0],((self.X),(self.X1))) or  between(x[0],((self.X1,(self.X)))):
                #If vertex coordinate y are is bewteen...
                if between(x[1],((self.Y),(self.Y1))) or  between(x[1],((self.Y1,(self.Y)))):
                    return True  #Ok, this vertex is part of my electrode.
                else:
                    return False #Nope, this isn't into electrode.


def GammaCircle(mesh, in_v, out_v, radius,centerx, centery):
    """
    Function to create a circle in the mesh with specified properties.

    :param mesh: Mesh.
    :type mesh: :class:`dolfin.cpp.mesh.Mesh`
    :param in_v: Value inside the circle.
    :type in_v: float
    :param out_v: Value outside the circle.
    :type out_v: float
    :param radius: Circle radius.
    :type radius: float
    :param centerx: Circle center position x.
    :type centerx: float
    :param centery: Circle center position y.
    :type centery: float
    
    :returns:  numpy.array -- Return a vector where each position corresponds to the value of the function in that element.
    
    :Example:

    >>> ValuesCells0 = GammaCircle(mesh=mesh_refined, in_v=3.0, out_v=1.0, radius=0.50, centerx=0.25, centery=0.25)
    >>> print(ValuesCells0)
        array([1., 1., 1., ..., 1., 1., 1.])
    >>> Q = FunctionSpace(mesh, "DG", 0) #Define Function space with basis Descontinuous Galerkin
    >>> gamma = Function(Q)
    >>> gamma.vector()[:]=ValuesCells0
    >>> plot_figure(gamma, name="", map="jet");
    
    .. image:: codes/gamma.png
        :scale: 75 %
    """

    ValuesGamma=np.zeros(mesh.num_cells()) #Null vector
    
    for i in range(0, mesh.num_cells()):
        cell = Cell(mesh, i) #Select cell with index i in the mesh.
        
        vertices=np.array(cell.get_vertex_coordinates()) #Vertex cordinate in the cell.
        x=(vertices[0]+vertices[2]+vertices[4])/3           
        y=(vertices[1]+vertices[3]+vertices[5])/3
        
        #If the baricenter is outside the circle...
        if ((x-centerx)**2+(y-centery)**2>=radius**2):
            ValuesGamma[i]=out_v
        else:
            ValuesGamma[i]=in_v
    
    return ValuesGamma
 

class ForwardProblem(object):
    """
    Object representing the Forward Problem in 2D EIT.

    :param mesh: Mesh.
    :type mesh: :func:`MyMesh()`
    :param z: Vector of impedances in electrodes.
    :type z: array-like

    :Example:

    >>> # Basic Definitions
    >>> L = 16
    >>> l = int(L)  # Measurements number.
    >>> z = np.ones(L) * 0.025  # Impedance
    >>> I_all = current_method(L, l, method=1)  # Current pattern

    >>> # Solver
    >>> VD = FiniteElement('CG', mesh_refined.ufl_cell(), 1)  # Space Solution
    >>> DirectProblem = ForwardProblem(mesh_refined, z)
    >>> list_u0, list_U0 = DirectProblem.solve_forward(VD, gamma0, I_all)
    >>> list_U0 = DirectProblem.sol_asarray()
    >>> print(list_U0[0:L])
        [1.0842557  0.32826713 0.19591977 0.13158264 0.06214628 -0.03412964
        -0.17331413 -0.40308837 -1.18449889 -0.42369776 -0.21120216 -0.08218106
        0.01735219 0.10789938 0.20976791 0.37492101]
    """
    
    def __init__(self, mesh, z):
        self.mesh=mesh
        self.z=z
        self.radius=mesh.radius
        self.ele_pos=mesh.electrodes.position     #electrodes position
        self.L=len(self.ele_pos)          #L electrodes.
        self.electrodes()                 #See function below, but it use class electrode_domain to set electrodes region.
        self.assembled=False
            
        
    def electrodes(self):
        """Auxiliar function, define subdomains with electrodes and calculates the size."""
        sub_domains = MeshFunction("size_t", self.mesh, self.mesh.topology().dim()-1) #MeshFunction 
        sub_domains.set_all(0) #Marking all vertex/edges with false.
 
        #Pass electrode position to mesh        
        list_e = [electrode_domain(self.mesh.vertex_elec[i], self.radius, self.L) for i in range(self.L)]
        #Here we have a array with objects that give us the information where is the vertex of each electrode in the mesh.
        
        #Mark electrodes in subdomain
        for index, elec in enumerate(list_e,1): elec.mark(sub_domains, index);
        #Noe we pass the information to the sub_domains with .mark(), where index is the electrode_index. index>=1
        
        #Generate 
        self.de=Measure('ds', domain=self.mesh, subdomain_data=sub_domains) #Defining integration Domain on electrodes.
        self.ele_size=np.array([assemble(Constant(1)*self.de(i+1)) for i in range(self.L)]) #Calc elec_size.
        self.list_e=list_e
        return
    
        
    def solve_forward(self, V, I_all, gamma): 
        """
        Solver for the Forward Problem of 2D Electrical Impedance Tomography (EIT).

        :param V: FiniteElement FEniCS object.
        :type V: :class:`dolfin.cpp.fem.FiniteElement`
        :param gamma: Finite Element Function representing the electrical conductivity distribution.
        :type gamma: :class:`dolfin.function.Function`
        :param I_all: Current density in each electrode for each measurement.
        :type I_all: :func:`current_method()` or list of arrays
    
        :returns: tuple -- A tuple containing two FEniCS objects, representing the potential distribution in the domain and the potentials at the electrodes, respectively.

        :Example:
        >>> DirectProblem = ForwardProblem(mesh_refined, z)
        >>> list_u0, list_U0 = DirectProblem.solve_forward(VD, I_all, gamma0)
        """
        de=self.de                        #Getting integral domain from memory.
        Intde=self.ele_size               #Size of electrodes.
        mesh=self.mesh
        
        #Verify if is a matrix or a simply vector
        I_all=np.array(I_all)
        self.I_forward=I_all
        if I_all.ndim==2:
            l=len(I_all)
        else: l=1
        
        #Finite element definition
        Rn=VectorElement("R", mesh.ufl_cell(), 0, dim=int(self.L)) #Vector in R_L for electrodes.
        R=FiniteElement("R", mesh.ufl_cell(), 0)                   #Constant for Lang. Mult    
        W=FunctionSpace(mesh, MixedElement([V, Rn, R]))       #Defining Mixed space V x R_l x R
        V_FuncSpace=FunctionSpace(mesh, V)       #Defining Mixed space V x R_l x R
        save_u=[]
        save_U=[]

        u0=TrialFunction(W) #Functions that will be reconstructed.
        v0=TestFunction(W)  #Test functions

        u, un, ul = split(u0)
        v, vn, vl = split(v0)

        # Integral( gamma*<grad_u,grad_v> ) dOmega + lagrMult
        A_inner=assemble(gamma* inner(grad(u),grad(v))*dx)

        if not self.assembled:
            lagrMult=0 #If that we have the ground potential. sum(electrode_i) = 0.
            for i in range(0,self.L): lagrMult+=(vn[i]*ul+un[i]*vl)*de(i+1) #Integral (v_i*u_mult+u_i*v_mult) d(electrode_i)
            self.A_lagr = assemble(lagrMult)


        # Integral 1/zi*(u-U_i)*(v-V_i) d(electrode_i)
        if not self.assembled:
            A_imp_0 = []
            for i in range(self.L): A_imp_0.append(assemble((u-un[i])*(v-vn[i])*de(i+1) ))
            self.A_imp_0 = A_imp_0
        A_imp = np.sum(self.A_imp_0*1/self.z)

        #Make my matriz to solve Ax=b.
        A=A_inner+A_imp+self.A_lagr 
        #We only do it only one time, if have mult. measurements, we reuse it.

        #Split w function in 3 parts, firt the function in H, the vector R^L, and the constant lagr
        w = Function(W) #Define a zero function based in W.
        u,U,u_lagr=w.split() 
        dm0 = W.sub(0).dofmap()
        dm1 = W.sub(1).dofmap()

        b0 = []
        for i in range(self.L): b0.append(assemble(vn[i]*(1/Intde[i])*de(i+1))) #Ax = sum (I_i*V_i)...
        #We integrate over electrode and divide by their size. If we don't make it, we get an error.

        A=scipy.sparse.csc_matrix(A.array())
        for j in range(l):
            I=I_all[j] if l!=1 else I_all #Is one measure or several?
            b = sum([b0[i]*I[i] for i in range(len(b0))]) #Make my b vector
            w = Function(W) #Define a zero function based in W.
            U_vec = w.vector()  #Return a vector. (x=U)
            #solve(A, U_vec, b) #Solve system AU=b. where A matrix and b vector.
            U_vec[:] = scipy.sparse.linalg.spsolve(A, b[:])

            #Append the result.
            u_aux=Function(V_FuncSpace)
            u_aux.vector()[:]= w.vector().vec()[dm0.dofs()]
            save_u.append(u_aux)
            save_U.append(w.vector().vec()[dm1.dofs()])

        self.sol_u, self.sol_U = save_u, save_U
        return self.sol_u, self.sol_U
    
    def sol_asarray(self):
        """
        Convert electrode potential results into an array and concatenate them.

        :returns: array -- A vector with concatenated potential values for all electrodes and measurements.

        :Example:
        >>> list_U0 = DirectProblem.sol_asarray()
        """
        list_U0=self.sol_U
        vec_U0=[]
        for i in range(len(list_U0)): vec_U0=np.concatenate((vec_U0, list_U0[i]), axis=0)
        return vec_U0
    
    def add_noise(self, noise_level=0, noise_type='uniform', seed=42):
        """
        Add noise to the potential values.

        :param noise_level: Noise level in percentage (between 0 and 1).
        :type noise_level: float
        :param noise_type: Type of noise to add ('uniform' or 'cauchy').
        :type noise_type: str.
        :param seed: Seed for the random number generator.
        :type seed: int

        :returns: array -- A vector with noised potential values for all electrodes and measurements.

        :Example:
        >>> list_U0_noised = DirectProblem.add_noise(noise_level=0.01, noise_type='uniform')
        """
        vec_U0=[]
        for i in range(len(self.sol_U)): vec_U0=np.concatenate((
            vec_U0, fn_addnoise(self.sol_U[i], noise_level, noise_type=noise_type, seed=seed)), axis=0)
        return vec_U0
    
    def select_potential(self, data, method=0):
        """
        Get a vector with the potential values and select a specific order.

        :param data: Potentials of all experiments.
        :type sol_index: array
        :param method: Method for selecting the potentials. 0 (do nothing) or 1 (select potentials).
        :type method: int

        :returns: array -- The selected potential values.

        :Example:
        >>> selected_U0 = DirectProblem.select_potential(list_U0, method=1)
        """
        L=self.L
        if method==1:
            if int(len(data)/L)>=L: raise Exception("This method only works with l<L") 
            data_save=[]
            j=0
            for i in range(np.size(data,0)):
                if i%L>=j:
                    data_save.append(data[i])
                if i%L==0: j+=1
            data_save=np.array(data_save)
            return data_save
        else: return data
    
    def verify_solution_graphs(self, gamma0, sol_index=0, method=1):
        """
        Plot boundary information to verify the solution.

        :param gamma0: Finite Element Function representing the electrical conductivity distribution.
        :type gamma0: :class:`dolfin.function.Function`
        :param sol_index: Index for the solution, ranging from 0 to l (number of measurements).
        :type sol_index: int
        :param method: Method for verification. 1: u+zi.gama.n.grad(u)=Ui, 2: boundary gamma.n.grad(u), 3: boundary gamma.n.grad(u) (only gaps).
        :type method: int

        :returns: array -- Plot boundary data.

        :Example:
        >>> data = DirectProblem.verify_solution_graphs(gamma0, sol_index=0, method=2)
        """
        mesh=self.mesh
        n = FacetNormal(mesh)
        u=self.sol_u[sol_index]
        de=self.de
        z=self.z

        VDG=FiniteElement('DG',mesh.ufl_cell(),0)
        Q=FunctionSpace(mesh,VDG)
        p, q = TrialFunction(Q), TestFunction(Q)
        M = assemble(inner(p, q)*ds)
        
        if method==1: L0 = inner(u+z[0]*inner(n,gamma0*grad(u)), q)*ds
        elif method==2: L0 = inner(inner(n,gamma0*grad(u)), q)*ds
        elif method==3: 
            M=assemble(inner(p, q)*de(0))
            L0 = inner(inner(n,gamma0*grad(u)), q)*de(0)
        
        b = assemble(L0)
        grad_u0 = Function(Q)
        x0 = grad_u0.vector()
        solve(M, x0, b)

        u_data =getBoundaryVertex(mesh, grad_u0);
        
        if method==1: name_='boundary u+zi.gama.n.grad(u)=Ui'
        elif method==2: name_='boundary gamma.n.grad(u)'
        elif method==3: name_='boundary gamma.n.grad(u) (only gaps)'
            
        data=plot_boundary(mesh, data=u_data, name=name_, line=0);
        return data

    def verify_solution_values(self, I_all, gamma0, sol_index=0, method=1):
        """
        Verify the solution values by comparing with the expected values.

        :param I_all: Current density in each electrode for each measurement.
        :type I_all: array or list of arrays
        :param gamma0: Finite Element Function representing the electrical conductivity distribution.
        :type gamma0: :class:`dolfin.function.Function`
        :param sol_index: Index for the solution, ranging from 0 to l (number of measurements).
        :type sol_index: int
        :param method: Method for verification. 1: Current values, 2: Average potential on electrodes.
        :type method: int

        :returns: None

        :Example:
        >>> DirectProblem.verify_solution_values(I_all, gamma0, sol_index=0, method=2)
        """
        set_log_level(50)
        mesh=self.mesh
        n = FacetNormal(mesh)
        u=self.sol_u[sol_index]
        list_U0=self.sol_U[sol_index]
        grad_u = grad(u)
        de=self.de
        z=self.z

        n = FacetNormal(mesh)
        sum0=0

        if not isinstance(I_all[0],float) or isinstance(I_all[0],int): I=I_all[0]
        else: I=I_all
        
        if method==1:
            print("Current values")
            for i in range(len(I)):
                integral=assemble(inner(n,gamma0*grad_u)*de(i+1))
                print("Calculated:", round(integral,4), "Expected:", I[i])
                sum0+=integral

            print("Soma das correntes calculada: ", sum0)
        elif method==2:
            #Average value potencial electrode.
            print("Potential values")
            for i in range(len(I)):
                integral1=assemble(inner(n,gamma0*grad_u)*de(i+1))*z[i]
                integral2=assemble(u*de(i+1))
                integral=(integral1+integral2)/self.ele_size[i]
                print("Calculated:", round(integral,5), "Expected:", round(list_U0[i],5))
        return
    
    



    
 
import copy

class InverseProblem(ForwardProblem):
    """
    Inverse Object EIT 2D.

    Class for solving inverse object electrical impedance tomography (EIT) problems in 2D. The inverse problem aims to reconstruct the electrical conductivity distribution within a domain based on measured electrical potentials at the boundary (electrodes).

    :param mesh: Any mesh from the Fenics module. We recommend using :func:`MyMesh()`.
    :type mesh: mesh
    :param data: Vector with the potentials measured at the electrodes or any other vector.
    :type data: array
    :param I_all: Current density in each electrode for each measurement. It can be a function generated using :func:`current_method()` or a list of arrays.
    :type I_all: :func:`current_method()` or list of arrays
    :param z: Vector of impedances in electrodes.
    :type z: array
    :param select_pot_method: Method to select the potential in the array. 0 - None, 1 - Select method. (Optional, Default: 0)
    :type select_pot_method: int

    :Example:
        
    Initialize the inverse problem and solve it:

    >>> InverseObject = InverseProblem(mesh_inverse, list_U0_noised, I_all, z)
    >>> InverseObject.solve_inverse()
    >>> gamma_k = InverseObject.gamma_k
    
    """
    def __init__(self, mesh, data, I_all, z=None, select_pot_method=0):
        super().__init__(mesh, z)
        #"Basic definitions"
        self.mesh=mesh
        self.V=FiniteElement('CG',mesh.ufl_cell(),1)  #Function Space CG degree 1 is necessary.
        self.Q_DG = FunctionSpace(self.mesh, "DG", 0)
        self.I=I_all          #Current pattern used in generated data.
        self.list_U0=data     #electrodes Potencial in array
        self.select_pot_method=select_pot_method  #Method select potencial in the array. 0 - None, 1- Select method
        #Verify if is a matrix or a simply vector
        self.I=np.array(self.I)
        if self.I.ndim==2:
            self.l=len(self.I)
        else: self.l=1

        #"First guess and weight functions"
        self.firstguess=np.ones(mesh.num_cells())           #First guess for Forwardproblem
        self.Cellsgamma_k=np.array(self.firstguess)                       #Solution in array.
        self.gamma_k = Function(self.Q_DG)
        self.gamma_k.vector()[:]=self.Cellsgamma_k
        self.weight=np.ones(mesh.num_cells())             #Initial weight function
        
        #"Solver configurations"
        self.verbose=False
        self.weight_value=False    #Are you going to use the weight function in the Jacobian matrix?
        self.step_limit=30        #Step limit while solve
        self.innerstep_limit=1000 #Inner step limit while solve
        self.min_v=1E-3           #Minimal value in element for gamma_k
        
        #"Noise Configuration"
        self.noise_level=0      #Noise_level from data (%) Ex: 0.01 = 1%
        self.tau=1.01           #Tau for disprance principle, tau>1
        
        #"Newton parameters"
        self.mu_i=0.9       #Mu initial (0,1]
        self.mumax=0.999    #Mu max
        self.nu=0.99        #Decrease last mu_n
        self.R=0.98         #Maximal decrease (%) for mu_n
        
        #"Inner parameters"
        self.inner_method='Landweber'  # Default inner method for solve Newton
        
        #Other Default parameters
        self.land_a=1    #Step-size Landweber
        self.ME_reg=5E-4 #Regularization Minimal Error
        self.Tik_c0=1    #Regularization parameter Iterative Tikhonov
        self.Tik_q=0.95  #Regularization parameter Iterative Tikhonov
        self.LM_c0=1     #Regularization parameter Levenberg-Marquadt
        self.LM_q=0.95   #Regularization parameter Levenberg-Marquadt
        
        #"A priori information"
        self.gamma0=None  #Exact Solution
        self.mesh0=None   #Mesh of exact solution
        
        #Creating a vector with all cell volumes. It's usefull for integrals in L2(Omega).
        cell_vec=[]
        for cell in cells(mesh):
            cell_vec.append(cell.volume())
        self.cell_vec=np.array(cell_vec)
        
        #Make a vector with electrodes size that are chosen for the problem
        #This vector is used in norm_L2(dOmega)
        self.size_elec_vec=self.select_potential(np.tile(self.ele_size, self.l), method=select_pot_method)
        
                #Banach Spaces parameters
        #Obs: Here we have several variables that we are working yet.
        self.Lp_space=2 #X, L_p space
        self.Lr_space=2 #Y, L_r space
    def solve_inverse(self):
        """Solve the inverse problem using a Newton-based method.

        This method is the main solver of the inverse problem. It iteratively solves the inverse EIT problem using a Newton-based method. The solution is stored in the `gamma_k` attribute.

        :Example:
        >>> InverseObject = InverseProblem(mesh_inverse, list_U0_noised, I_all, z)
        >>> InverseObject.solve_inverse()
        """
        "Creating basic informations."
        res_vec, error_vec=[], [] #To save about iterations
        self.innerstep_vec=[]     #Save inner_step newton
        mun_vec=[]                #Save mu in inner_step newton     
        gamma_all=np.array([])    #Saving all gamma_k
        self.steps=0              #Save external step.
        r=self.Lr_space #Data space L^r

        ##############################################
        "First Forward solver"
        self.list_u , self.list_U= self.solve_forward(self.V, self.I, self.gamma_k)
        self.list_U=np.array(self.list_U).flatten() #Convert to array
        self.list_U=self.select_potential(self.list_U, method=self.select_pot_method)
        b0 = self.list_U0-self.list_U #Define vector b0 (Ask=b0)
        
        "First Save data"
        #Residual vector
        res_vec.append(self.norm_funcL2(b0,           'dOmega', r)/
                       self.norm_funcL2(self.list_U0, 'dOmega', r)*100)
        self.innerstep_vec.append(int(0)) #Save inner number steps
        mun_vec.append(0)                 #Save number steps
        
        "Print information"
        if self.mesh0 is not None and self.gamma0 is not None and self.verbose:
            error_vec.append(self.error_gamma())    
            print("Error (%):", error_vec[0], "Residual (%):", res_vec[0], "step:", 0, "Inner step:", 0)
        elif self.verbose:
            print("Residual (%):", res_vec[0], "step:", 0, "Inner step:", 0)
            
        "Solver"
        ##############################################
        #While discepancy or limit steps.
        while res_vec[self.steps]/100>=self.tau*self.noise_level and self.steps<self.step_limit:
            
            "Inner iteration newton"
            Jacobiana_all=self.Jacobian_calc()        #Derivative matrix calc
            sk, inner_step, mu=self.solve_innerNewton(Jacobiana_all, b0)
            self.Cellsgamma_k+=sk #Add a correction in each element
            
            #Don't have values less than c.s
            self.Cellsgamma_k[self.Cellsgamma_k < self.min_v] = self.min_v
            self.gamma_k.vector()[:]=self.Cellsgamma_k
            
            
            "Forward solver"
            self.list_u , self.list_U= self.solve_forward(self.V, self.I, self.gamma_k)
            self.list_U=np.array(self.list_U).flatten() #Convert to array
            self.list_U=self.select_potential(self.list_U, method=self.select_pot_method)
            b0 = self.list_U0-self.list_U #Define vector b0 (Ask=b0)
            
            "Saving data"
            #Saving gamma.
            if self.steps==0: gamma_all=np.array(self.Cellsgamma_k)
            else:  gamma_all=np.vstack((gamma_all, (np.array(self.Cellsgamma_k))))
                
            #Append residuo
            res_vec.append(self.norm_funcL2(b0,           'dOmega', r)/
                           self.norm_funcL2(self.list_U0, 'dOmega', r)*100)
            
            self.innerstep_vec.append(int(inner_step)) #Save number steps
            mun_vec.append(mu)                         #Save number steps
            
            #If we have exact solution, save error.
            if self.mesh0 is not None and self.gamma0 is not None:
                error_vec.append(self.error_gamma())
                
            self.steps+=1 #Next step.
            
            #Print information
            if self.mesh0 is not None and self.gamma0 is not None and self.verbose:
                print("Error (%):", np.round(error_vec[self.steps],6), "Residual (%):", np.round(res_vec[self.steps], 6),
                      "step:", self.steps, "Inner step:", inner_step, "mu_n:", np.round(self.mu, 6))
            elif self.verbose: print("Residual (%):", np.round(res_vec[self.steps],6),
                      "step:", self.steps, "Inner step:", inner_step, "mu_n:", np.round(self.mu, 6))
            ####################
            #Vectors to memory object.
            self.gamma_all=np.copy(gamma_all)
            self.res_vec=res_vec
            self.mun_vec=mun_vec
            self.error_vec=error_vec
            
        #############End-While############################
        return
   
        
    def solve_innerNewton(self, Jacobiana_all,b0):
        """Solve the inner step of the Newton method.

        This method is used to solve the inner step of the Newton method. It iteratively updates the solution `gamma_k` using different regularization methods.

        :param Jacobiana_all: Derivative Matrix generated by :func:`Jacobian_calc()`.
        :type Jacobiana_all: ndarray
        :param b0: Vector containing the difference between the measured potentials and the potentials calculated with the current guess.
        :type b0: array

        :returns: (Array, int, float) -- Returns `sk` (the result of the inner step to add to `gamma_k`), `inner_step` (number of inner steps taken), `mu` (regularization parameter used in the method).
        """        
        #If weight True and step=0, determine the weight.
        if self.weight_value and self.steps==0: self.weight_func(Jacobiana_all) 
            
        ADJ=(Jacobiana_all*1/self.weight).T #Add weight.
        norm_b0=self.norm_funcL2(b0, 'dOmega', self.Lr_space)
        residuo=-b0            #Define res.
        norm_res=norm_b0       #Define norm_res first step.
        
        mu = self.newton_reg() #Calculate regularation parameter.
        inner_step=0
        
        sk=np.zeros(self.mesh.num_cells()) #s0 inicial do newton
        
        "------Landweber------"
        if self.inner_method=='Landweber':
            while norm_res>=mu*norm_b0 and inner_step<self.innerstep_limit:
                sk+=-self.land_a*ADJ@residuo

                residuo=-b0+Jacobiana_all@sk
                norm_res = self.norm_funcL2(residuo, 'dOmega')
                inner_step+=1
                
            "------Minimal Error------"
        elif self.inner_method=='ME' :
            while norm_res>=mu*norm_b0 and inner_step<self.innerstep_limit:
                sk_n=-ADJ@residuo
                omega=self.norm_funcL2(residuo, 'dOmega')**2/self.norm_funcL2(sk_n, 'Omega')**2*self.ME_reg
                sk+=omega*sk_n

                residuo=-b0+Jacobiana_all@sk
                norm_res = self.norm_funcL2(residuo, 'dOmega')
                inner_step+=1
        
            "------Conjugate-Gradient------"
        elif self.inner_method=='CG' :
            while norm_res>=mu*norm_b0 and inner_step<self.innerstep_limit:
                if inner_step==0:
                    rk=b0
                    ak=ADJ@rk
                    pk=ak
                    ak_old=ak                    

                qk=Jacobiana_all@pk
                alphak=(self.norm_funcL2(ak_old, 'Omega')**2)/(self.norm_funcL2(qk, 'dOmega')**2)
                sk=sk+alphak*pk
                rk=rk-alphak*qk
                ak=ADJ@rk
                betak=(self.norm_funcL2(ak, 'Omega')**2)/(self.norm_funcL2(ak_old, 'Omega')**2)
                pk=ak+betak*pk

                ak_old=ak
                residuo=-b0+Jacobiana_all@sk
                norm_res = self.norm_funcL2(residuo, 'dOmega')
                inner_step+=1
                

                
            "------Iterative Tikhonov------"
        elif self.inner_method=='Tikhonov':
            square_m0=ADJ@Jacobiana_all
            while norm_res>=mu*norm_b0 and inner_step<self.innerstep_limit:
                alpha_k=self.Tik_c0*(self.Tik_q**inner_step)
                square_m=square_m0+alpha_k*np.identity(np.size(square_m0, axis=0))
                sk+=np.linalg.solve(square_m, ADJ.dot(b0-Jacobiana_all@sk)) #Verificar com fab


                residuo=-b0+Jacobiana_all@sk
                norm_res = self.norm_funcL2(residuo, 'dOmega')
                inner_step+=1
                
            "------Levenberg-Marquadt------"
        elif self.inner_method=='LM':
            square_m0=ADJ@Jacobiana_all
            while norm_res>=mu*norm_b0 and inner_step<self.innerstep_limit:
                alpha_k=self.LM_c0*(self.LM_q**inner_step)
                square_m=square_m0+alpha_k*np.identity(np.size(square_m0, axis=0))
                sk=np.linalg.solve(square_m, ADJ.dot(b0))

                residuo=-b0+Jacobiana_all@sk
                norm_res = self.norm_funcL2(residuo, 'dOmega')
                inner_step+=1   
                

        return sk, inner_step, mu
        
    def Jacobian_calc(self):
        """Calculate the derivative matrix (Jacobian).

        This method calculates the derivative matrix (Jacobian) required for the inverse EIT problem.

        :returns: (ndarray) -- Returns the derivative matrix.
        """
        BU_save=[] #Save potential electrodes
        bu_save=[] #Save potential domain
        list_u=self.list_u           #Get potential domain list
        
        
        
        #Construction new current pattern for Jacobian calc.
        #Ref: https://fabiomargotti.paginas.ufsc.br/files/2017/12/Margotti_Fabio-3.pdf chap 5.2.1
        I2_all=[]  #We will use to construct a smart way to calc. Jacobian
        for i in range(self.L):
            #I2_i=1 at electrode i and zero otherwise
            I2=np.zeros(self.L)
            I2[i]=1
            I2_all.append(I2)
        
        bu,BU=self.solve_forward(self.V, I2_all, self.gamma_k)
        bu_save=bu
        
        
        #separating electrodes data
        select_data=np.tile(range(0,self.L), self.l)
        select_data=self.select_potential(select_data, method=self.select_pot_method)
        select_data = np.split(select_data, np.where(select_data[:-1] == self.L-1)[0]+1)
        
        Q_DG = VectorFunctionSpace(self.mesh, "DG", 0, dim=2)
        list_grad_u = [project(grad(u), Q_DG).vector()[:].reshape(-1, 2) for u in list_u]
        list_grad_bu = [project(grad(bu), Q_DG).vector()[:].reshape(-1, 2) for bu in bu_save]      

        for h in range(self.l): #For each experiment
            derivada=[]
            for j in select_data[h]: #for each electrode
                derivada.append(-1*np.sum(list_grad_bu[j]*list_grad_u[h], axis=1)) #Get the function value in eache element
                
            Jacobiana=derivada*self.cell_vec #Matrix * Volume_cell
            if h==0: Jacobiana_all=Jacobiana #Append all jacs.
            else: Jacobiana_all=np.concatenate((Jacobiana_all, Jacobiana), axis=0)
                
        return Jacobiana_all
    
    def weight_func(self, Jacobiana):
        """Determine the weights for the derivative matrix and apply them.

        This method determines the weights for the derivative matrix and applies them. The weights are used to improve the convergence of the Newton-based method.

        :param Jacobiana: Derivative Matrix generated by :func:`Jacobian_calc()`.
        :type Jacobiana: ndarray

        :returns: (ndarray) -- Returns the derivative matrix with weights.
        """
        p=self.Lp_space
        #norm(Jacobian_line)*1/vol_cell_k*1/gamma_cell_k
        self.weight=np.linalg.norm(Jacobiana, ord=p, axis=0)*(1/self.cell_vec)*(1/self.Cellsgamma_k)
        return self.weight
    
    def newton_reg(self):
        """Determine the regularization parameter for the Newton inner step.

        This method determines the regularization parameter used in the Newton inner step, considering the Newton method's progress.

        :returns: (float) -- Returns the regularization parameter `mu`.
        """
        #ref: https://doi.org/10.1137/040604029
        passo=self.steps
        innerstep_vec=self.innerstep_vec
        
        if passo>1:
            if innerstep_vec[passo-1]>=innerstep_vec[passo-2]: #If inner step increase
                mu_n=1-((innerstep_vec[passo-1]/innerstep_vec[passo])*(1-self.mu))
            else: mu_n=self.nu*self.mu #Remmember, nu<1.
            mu=self.mumax*np.amax([self.R*self.mu, mu_n]) #R limits how much the mu_n change.
        else: mu=self.mu_i #For the two first steps.
        
        self.mu=mu
        return mu
    
    def norm_funcL2(self, vector, domain, p=2):
        """Calculate the L2 norm of the vector.

        This method calculates the L2 norm of the input vector for the given domain.

        :param vector: Input vector.
        :type vector: array
        :param domain: The domain for which the norm is calculated. It can be 'Omega' or 'dOmega'.
        :type domain: str
        :param p: Power of the norm. (Optional, Default: 2)
        :type p: int

        :returns: (float) -- Returns the L2 norm of the vector for the specified domain.
        """
        mesh=self.mesh
        weight=self.weight
        if domain=='Omega':
            norm=sum(abs(vector)**p*self.cell_vec*weight)
        elif domain=="dOmega":
            norm=sum(abs(vector)**p*self.size_elec_vec)

        norm=norm**(1/p)
        return norm
    
    def error_gamma(self):
        """Calculate the percentual error in L2 of the exact and reached solution for gamma.

        This method calculates the percentage error in the L2 norm between the exact and the reached solution for gamma. To use this method, the exact solution should be set using :func:`set_answer()`.

        :returns: (float) -- Returns the percentage error in the L2 norm.
        """
        V0=FiniteElement('DG',self.mesh.ufl_cell(),0)
        V1=FiniteElement('DG',self.mesh0.ufl_cell(),0)
        
        Q0=FunctionSpace(self.mesh0, V0)
        Q1=FunctionSpace(self.mesh, V1)
        
        GammaElement0=interpolate(self.gamma0, Q0) #Interpolate to mesh_refined
        GammaElement1=interpolate(self.gamma_k, Q1) #interpolate gamma_k to mesh_inverse
        GammaElement1=interpolate(GammaElement1, Q0)#Interpolate from mesh_inverse to mesh_refined
        
        error_L2 = errornorm(GammaElement0, GammaElement1, 'L2') #Error norm
        norm_gamma0 = norm(GammaElement0, 'L2')                  #Norm exact solution
        GammaError=error_L2/norm_gamma0*100                      #percentual.
        
        if self.steps<=1:
            cell_vec0=[]
            for cell in cells(self.mesh0): cell_vec0.append(cell.volume())
            self.cell_vec0=np.array(cell_vec0)        
        
        #A way to calculated the error in a different norm.
        if self.Lp_space!=2:
            #Error norm
            error_Lp=sum(abs((np.array(GammaElement1.vector())-np.array(GammaElement0.vector())))**self.Lp_space*self.cell_vec0 )
            error_Lp=error_Lp**(1/self.Lp_space)
            #Exact norm
            norm_gamma0_Lp=sum(abs((np.array(np.array(GammaElement0.vector())))**self.Lp_space*self.cell_vec0 ))
            norm_gamma0_Lp=norm_gamma0_Lp**(1/self.Lp_space)
            
            GammaError_Lp= error_Lp/norm_gamma0_Lp*100 #Percentual
        #print(GammaError_Lp)
        
        return GammaError
    
    def set_answer(self, gamma0, mesh0):
        """
        Set the exact solution for gamma.

        This method sets the exact solution (gamma0) and its corresponding mesh (mesh0) to be used for comparison and error calculation. This is useful to determine the best solution reached.

        :param gamma0: Finite Element Function representing the exact solution for gamma.
        :type gamma0: Function
        :param mesh0: Mesh
        :type mesh0:  :func:`MyMesh`

        :Example:
        >>> InverseObject=InverseProblem(mesh_inverse, list_U0_noised, I_all, z)
        >>> InverseObject.set_answer(gamma0, mesh_refined)

        """
        self.gamma0=gamma0
        self.mesh0=mesh0
        return
    
    def set_NewtonParameters(self,  **kwargs):
        """Set Newton Parameters for the inverse problem.

        Kwargs:
            * **mu_i** (float): Initial value for mu (0, 1].
            * **mumax** (float): Maximum value for mu (0, 1].
            * **nu** (float): Factor to decrease the last mu_n.
            * **R** (float): Minimal value for mu_n.

        Default Parameters:
            >>> self.mu_i = 0.9
            >>> self.mumax = 0.999
            >>> self.nu = 0.99
            >>> self.R = 0.9

        :Example:
        >>> InverseObject = InverseProblem(mesh_inverse, list_U0_noised, I_all, l, z)
        >>> InverseObject.set_NewtonParameters(mu_i=0.90, mumax=0.999, nu=0.985, R=0.90)
        """
        for arg in kwargs:
            setattr(self, arg, kwargs[arg])
        return
        
    def set_NoiseParameters(self, tau, noise_level):
        """
        Set Noise Parameters for stopping with the Discrepancy Principle.

        :param tau: Tau value for the discrepancy principle [0, ∞).
        :type tau: float
        :param noise_level: Noise level (%) in the data [0, 1).
        :type noise_level: float

        Default Parameters:
            >>> self.tau = 0
            >>> self.noise_level = 0

        :Example:
        >>> InverseObject = InverseProblem(mesh_inverse, list_U0_noised, I_all, l, z)
        >>> InverseObject.set_NoiseParameters(tau=5, noise_level=0.01)
        """
        self.tau=tau
        self.noise_level=noise_level
        
    def set_firstguess(self, Cellsgamma_k):
        """Set default parameters for the first guess in the external step Newton.

        :param Cellsgamma_k: A vector representing the initial values of gamma in each cell.
        :type Cellsgamma_k: array

        Default Parameters:
            >>> self.Cellsgamma_k = np.ones(self.mesh.num_cells()) * 0.9

        :Example:
        >>> InverseObject = InverseProblem(mesh_inverse, list_U0_noised, I_all, l, z)
        >>> InverseObject.set_firstguess(np.ones(mesh_inverse.num_cells()) * 5)
        """
        self.firstguess=Cellsgamma_k           #First guess for Forwardproblem
        self.Cellsgamma_k=self.firstguess           
        self.gamma_k.vector()[:]=self.Cellsgamma_k #Guess in cell function """
        
    def set_solverconfig(self, **kwargs):
        """Set Solver configuration for the inverse problem.

        Kwargs:
            * **weight_value** (bool): Use a weight function in the Jacobian matrix.
            * **step_limit** (float): Step limit while solving.
            * **min_v** (float): Minimal value in an element for gamma_k.

        Default Parameters:
            >>> self.weight_value = True
            >>> self.step_limit = 5
            >>> self.min_v = 0.05

        :Example:
        >>> InverseObject = InverseProblem(mesh_inverse, list_U0_noised, I_all, l, z)
        >>> InverseObject.set_solverconfig(weight_value=True, step_limit=200, min_v=0.01)
        """    
        for arg in kwargs:
            setattr(self, arg, kwargs[arg])

    def set_InnerParameters(self, **kwargs):
        """Set Inner-step Newton Parameters for the inverse problem.

        Kwargs:
            * **inner_method** (str): Method to solve the inner step Newton. Options: 'Landweber', 'CG', 'ME', 'LM', 'Tikhonov'.
            * **land_a** (int): Step-size for Landweber method.
            * **ME_reg** (float): Minimal value in an element for gamma_k.
            * **Tik_c0** (float): Regularization parameter for Iterative Tikhonov.
            * **Tik_q** (float): Regularization parameter for Iterative Tikhonov.
            * **LM_c0** (float): Regularization parameter for Levenberg-Marquardt.
            * **LM_q** (float): Regularization parameter for Levenberg-Marquardt.

        Default Parameters:
            >>> self.inner_method = 'Landweber'
            >>> self.land_a = 1
            >>> self.ME_reg = 5E-4
            >>> self.Tik_c0 = 1
            >>> self.Tik_q = 0.95
            >>> self.LM_c0 = 1
            >>> self.LM_q = 0.95

        :Example:
        >>> InverseObject = InverseProblem(mesh_inverse, list_U0_noised, I_all, l, z)
        >>> InverseObject.set_InnerParameters(inner_method='ME', ME_reg=5E-4)
        """
        for arg in kwargs:
            setattr(self, arg, kwargs[arg])

import matplotlib.pyplot as plt
from matplotlib.patches import Wedge,Arc

def plot_figure(function, name, save=False, map='inferno'):
    """
    Plot a given function with an optional color map and save the plot if specified.

    :param function: The function to plot.
    :type function: :class:`dolfin.function.Function`
    :param name: The title of the plot.
    :type name: str
    :param save: If True, save the plot with the title as the filename.
    :type save: bool, optional
    :param colormap: The name of the colormap to use for the plot.
    :type colormap: str, optional
    
    :returns: None

    :Example:

    >>> plot_figure(u, "Potential Field", save=True, colormap='viridis')
    """
    plt.figure()
    p=plot(function, title=name)
    p.set_cmap(map)
    #p.set_clim(0.0, 4.0)
    plt.colorbar(p)
    if save==True: plt.savefig(name)
    return 



def getBoundaryVertex(mesh,u):
    """
    Get the values of a function `u` at the boundary vertices of a given `mesh`.

    :param mesh: The input mesh.
    :type mesh: Mesh
    :param u: The function to evaluate at the boundary vertices.
    :type u: Function

    :return: A list of function values at the boundary vertices.
    :rtype: list
    """
    u_bvertex=[]
    u_bvertex_ind=[]
    bmesh=BoundaryMesh(mesh, 'exterior', order=True)
    indice_borda=bmesh.entity_map(0).array()
    
    for ind in indice_borda:
        u_bvertex.append(u.compute_vertex_values()[ind]) #pra pegar os valores, apenas na borda, como array
    return u_bvertex


def plot_boundary(mesh, data, name='boundary', line=2, data2=1, save=False, plot=True):
    """
    Plot the boundary of a mesh along with `data`.

    :param mesh: The mesh to plot.
    :type mesh: Mesh
    :param data: The data to plot on the boundary.
    :type data: numpy.ndarray
    :param name: The name of the plot (default 'boundary').
    :type name: str
    :param line: The line width for plotting (default 2).
    :type line: int
    :param data2: Additional data to plot (default 1).
    :type data2: int or numpy.ndarray
    :param save: Whether to save the plot (default False).
    :type save: bool
    :param plot: Whether to display the plot (default True).
    :type plot: bool

    :return: The boundary plot as a numpy array.
    :rtype: numpy.ndarray
    """
    tol=0.0
    bmesh=BoundaryMesh(mesh, 'exterior', order=True)
    indice_borda=bmesh.entity_map(0).array()
    boundary_plot1, boundary_plot2=[], []
    for ind in range(len(indice_borda)):
        vertex = Vertex(mesh, indice_borda[ind])
        if vertex.x(1)>=tol:
            theta=np.arccos(vertex.x(0))
            boundary_plot1.append([theta, data[ind]])
    boundary_plot1=np.array(boundary_plot1)
    max_b=np.max(boundary_plot1[:,0])        

    
    for ind in range(len(indice_borda)):
        vertex = Vertex(mesh, indice_borda[ind])    
        if vertex.x(1)<0:
            theta=np.arccos(-vertex.x(0))+max_b
            boundary_plot2.append([theta, data[ind]])
    
    boundary_plot=np.concatenate((boundary_plot1, boundary_plot2), axis=0)
    
    
    boundary_plot=boundary_plot[boundary_plot[:,0].argsort()]
    #boundary_plot=np.sort(boundary_plot.view('i8'), order=['f1'], axis=0)

    if plot==True:
        plt.figure()
        plt.title(name)
        if type(data2)!=type(1):
            plt.plot(data2[:,0], data2[:,1], marker='.', markersize=2, linewidth=line, label="Dados")    
        plt.plot(boundary_plot[:,0], boundary_plot[:,1], marker='.', markersize=2, linewidth=line, label="Resultado")
        #plt.legend()
        if save==True: plt.savefig(name)
    
    return boundary_plot

def plot_electrodes(mesh, linewidth_mesh = 1, linewidth_elec=5, figsize=(5,5), fontsize=20, elec_num=True, axis=False):
    """
    Plot the electrodes on a mesh.

    :param mesh: A mesh object.
    :type mesh: Mesh
    :param linewidth_mesh: The width of the mesh lines (default 1).
    :type linewidth_mesh: int
    :param linewidth_elec: The width of the electrode lines (default 5).
    :type linewidth_elec: int
    :param figsize: The size of the figure (default (5,5)).
    :type figsize: tuple
    :param fontsize: The font size of the electrode numbers (default 20).
    :type fontsize: int
    :param elec_num: Whether to show electrode numbers (default True).
    :type elec_num: bool
    :param axis: Whether to show the axis (default False).
    :type axis: bool

    :return: The figure object.
    :rtype: matplotlib.figure.Figure
    """
    
    fig, ax = plt.subplots(figsize=figsize)
    mesh_radius = mesh.radius
    theta_vec = np.degrees(np.array(mesh.electrodes.position))

    for index, theta in enumerate(theta_vec):
        theta_start, theta_end = theta[0], theta[1]
        centertheta = (abs(theta_start-theta_end)/2+theta_start)/360*(2*np.pi)
        #Plotting arc
        arc = Arc((0, 0), 2 * mesh_radius * 1.01, 2 * mesh_radius * 1.01, angle=0,
                theta1=theta_start, theta2=theta_end, linewidth=linewidth_elec, color='black')
        #Plotting Electrode number
        if elec_num:
            x, y = mesh_radius*np.cos(centertheta)*1.1, mesh_radius*np.sin(centertheta)*1.1
            ax.annotate(index+1, (x, y), color='black', weight='bold', fontsize=fontsize, ha='center', va='center')
        ax.add_artist(arc)

    ax.set_aspect(1)
    plot(mesh, linewidth=linewidth_mesh)
    
    if not axis:
        plt.xticks([])
        plt.yticks([])
        plt.box(False)
    return 


def EstimateDelta(list_U_noised: np.ndarray, I: np.ndarray) -> float:
    """
    
    Estimate the noise level in potential measurements obtained from a grounded electrode system. The method was based on 
    
    Robert Winkler work: A model-aware inexact Newton scheme for electrical impedance tomography, 2016.

    :param list_U_noised: Noisy potential measurements with shape (l, L).
    :type list_U_noised: numpy.ndarray
    :param I: Current pattern matrix with shape (l, L).
    :type I: numpy.ndarray

    :return: A scalar value representing the estimated noise level in the potential measurements.
    :rtype: float

    :notes:
        The data must be measured through a grounded electrode, i.e., the sum of potential of each of the electrodes must be zero.

    This function estimates the noise level in potential measurements obtained from a grounded electrode system. It takes two
    arguments as inputs: `list_U_noised` and `I`.
    """
    l, L = np.shape(I)
    list_U_noised = list_U_noised.reshape((l, L))
    Iplus = np.linalg.pinv(I)

    ev = (Iplus @ list_U_noised) - (Iplus @ list_U_noised).T
    norm_ev = np.linalg.norm(ev, ord="fro") ** 2
    norm_Iplus = np.linalg.norm(Iplus, ord="fro")
    vCEM = norm_ev / (2 * (L - 1)) * norm_Iplus ** (-2)
    delta_calc = np.sqrt(l * L * vCEM)

    return delta_calc

def ConvertingData(U,method):
    """
    Convert data from different measurement patterns to the ground pattern.

    :param U: The data to be converted.
    :type U: numpy.ndarray
    :param method: The measurement pattern to be converted to. Currently only "KIT4" is supported.
    :type method: str

    :return: The converted data.
    :rtype: numpy.ndarray
    """
    if method=="KIT4": 
        #See: https://arxiv.org/pdf/1704.01178.pdf
        L=len(U)
        U_til = np.zeros(L)
        for i in range(1,L): U_til[i]=np.sum(U[:i])
        c = np.sum(U_til)
        return c/L-U_til
    return U

def EstimateCond(list_U0, I, mesh, z, method="CONT"):
    """
    Estimate the conductivity of the background based on noisy voltage measurements.

    :param list_U0: A list of noisy voltage measurements.
    :type list_U0: list
    :param I: A current pattern matrix.
    :type I: numpy.ndarray
    :param mesh: A mesh object.
    :type mesh: Mesh
    :param z: The background impedance (default 1E-5).
    :type z: numpy.ndarray
    :param method: The method used for estimating conductivity. Options: "CONT", "SHUNT", "CEM1", "CEM2".
    :type method: str

    :return: A tuple containing the estimated conductivity and minimum potential.
    :rtype: tuple(float, float)
    """
    l, L = np.shape(I)
    gamma = Function(FunctionSpace(mesh, "DG", 0))
    gamma.vector()[:]=np.ones(mesh.num_cells())

    #Solver
    VD=FiniteElement('CG',mesh.ufl_cell(),1) #Solution Space Continous Galerkin
    ForwardObject=ForwardProblem(mesh,  z)
    _, list_U = ForwardObject.solve_forward(VD, I, gamma)

    list_U0 = np.array(list_U0).reshape(l,L)
    if method=="CONT":
        list_U=np.array(list_U).flatten()
        list_U0=np.array(list_U0).flatten()
        cond = np.linalg.norm(list_U)**2/np.dot(list_U, list_U0)
        return cond
    if method=="SHUNT":
        U_1=[np.dot(list_U[i],I[i]) for i in np.arange(l)]
        U_2=[np.dot(list_U0[i],I[i]) for i in np.arange(l)]
        cond=np.linalg.norm(U_1)**2/np.dot(U_1,U_2)
        return cond
    if method == "CEM1":
        z0=np.max(z)
        elec_lenght = mesh.radius*(mesh.electrodes.calc_position()[0][1]-mesh.electrodes.calc_position()[0][0])
        U_1=[np.dot(list_U[i]-I[i]*z0/elec_lenght,I[i]) for i in np.arange(l)]
        U_2=[np.dot(list_U0[i]-I[i]*z0/elec_lenght,I[i]) for i in np.arange(l)]
        cond=np.dot(U_1,U_2)/np.linalg.norm(U_2)**2
        return cond
    if method == "CEM2":
        z0=np.max(z)
        elec_lenght = mesh.radius*(mesh.electrodes.calc_position()[0][1]-mesh.electrodes.calc_position()[0][0])

        a_vec=[np.dot(list_U[i]-I[i]*z0/elec_lenght, I[i]) for i in np.arange(l)]
        b_vec=[np.dot(I[i],I[i]/elec_lenght) for i in np.arange(l)]
        c_vec = [np.dot(list_U0[i],I[i])for i in np.arange(l)]

        A = np.array([a_vec, b_vec]).T
        x0 = scipy.optimize.nnls(A, c_vec)
        rho, z = x0[0]
        cond = 1/rho
        return cond, z
    
def EstimateCondIterative(list_U0, I, mesh, z, zmin=1E-5):
    """
    Estimate the conductivity of the background based on noisy voltage measurements using an iterative approach.

    :param list_U0: A list of noisy voltage measurements.
    :type list_U0: list
    :param I: A current pattern matrix.
    :type I: numpy.ndarray
    :param mesh: A mesh object.
    :type mesh: Mesh
    :param z: The background impedance (default 1E-5).
    :type z: numpy.ndarray
    :param zmin: The minimum background impedance value (default 1E-5).
    :type zmin: float

    :return: A tuple containing the estimated conductivity and impedance.
    :rtype: tuple(float, float)
    """
    def fun(zi, list_U0, I, mesh, z):
        l, L = np.shape(I)
        cond, z = EstimateCond(list_U0, I, mesh, zi, method="CEM2")
        z=np.max([zmin, z])

        Q_DG=FunctionSpace(mesh, "DG", 0)
        gamma = Function(Q_DG)
        gamma.vector()[:]=np.ones(mesh.num_cells())*cond

        ForwardObject=ForwardProblem(mesh,  z*np.ones(L))
        VD=FiniteElement('CG',mesh.ufl_cell(),1) #Solution Space Continous Galerkin
        _, list_U = ForwardObject.solve_forward(VD, I, gamma)
        list_U = np.array(list_U).flatten()

        res = np.linalg.norm(list_U - list_U0)/np.linalg.norm(list_U0)*100
        #print(res)
        return  res
    
    data = scipy.optimize.minimize(fun, 1E-5, args=(list_U0, I, mesh, z))
    z_optimal=data['x']
    cond_optimal, z_optimal = EstimateCond(list_U0, I, mesh, z_optimal, method="CEM2")
    return cond_optimal, z_optimal
